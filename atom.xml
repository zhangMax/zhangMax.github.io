<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wonkey Zhang</title>
  <icon>https://www.gravatar.com/avatar/52f4c6aa1dd1284f9fdf1f9ff8036d97</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wonkeyz.com/"/>
  <updated>2018-01-10T02:41:38.296Z</updated>
  <id>http://wonkeyz.com/</id>
  
  <author>
    <name>Wonkey Zhang</name>
    <email>zhangQiangView@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WZRunLoopObserver</title>
    <link href="http://wonkeyz.com/2017/11/17/WZRunLoopObserver/"/>
    <id>http://wonkeyz.com/2017/11/17/WZRunLoopObserver/</id>
    <published>2017-11-17T07:25:53.000Z</published>
    <updated>2018-01-10T02:41:38.296Z</updated>
    
    <content type="html"><![CDATA[<p>之前写的<a href="http://www.wonkeyz.com/2017/07/22/Runloop-Learning-summary/" target="_blank" rel="external">RunLoop学习总结</a>文章中提到了利用 RunLoop 解决在tableView中同时加载多个大图卡顿的方案<a href="https://github.com/diwu/RunLoopWorkDistribution" target="_blank" rel="external">RunLoopWorkDistribution</a>，它的解决思路是在一次 RunLoop 时候只绘制一张图片，这样每次 RunLoop 需要处理的操作变少，从而避免卡顿。受它的启发我最近写了一个方案来解决这个问题，与其相同的也是监听每次 RunLoop 的空闲时(<code>kCFRunLoopBeforeWaiting</code>)来完成一次任务，不同的是更加易用，支持功能更齐全，下面我来简单介绍下。<br><a id="more"></a><br>先来看下接口:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WZRunLoopObserver</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 主任务队列, observer不会移除</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main;</div><div class="line"> */</div><div class="line">+ (WZRunLoopObserver *)main;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 自定义队列, 当任务数为0时, 会在当前RunLoop循环n次后移除observer, n默认值为100</div><div class="line"> </div><div class="line"> WZRunLoopObserver.queue(@"com.wonkeyz.queue");</div><div class="line"> */</div><div class="line">+ (WZRunLoopObserver *(^)(<span class="built_in">NSString</span> *))queue;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 添加任务</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main.add(dispatch_block_t task).add(...);</div><div class="line"> */</div><div class="line">- (WZRunLoopObserver *(^)(dispatch_block_t))add;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 取消任务</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main.cancel(dispatch_block_t task)</div><div class="line"> */</div><div class="line">- (WZRunLoopObserver *(^)(dispatch_block_t))cancel;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 限制任务个数, 默认不限制, 超出后会移除先添加的任务</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main.limit(n).add(...);</div><div class="line"> */</div><div class="line">- (WZRunLoopObserver *(^)(<span class="built_in">NSUInteger</span>))limit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 缓存超出限制的任务, 当任务队列不再超限时将缓存的任务添加到任务队列中, 默认关闭</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main.limit(10).cache.add(...);</div><div class="line"> */</div><div class="line">- (WZRunLoopObserver *(^)(<span class="built_in">BOOL</span>))cache;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> 延迟调用任务, 在当前RunLoop循环n次后执行任务</div><div class="line"> </div><div class="line"> WZRunLoopObserver.main.delay(n).add(...);</div><div class="line"> */</div><div class="line">- (WZRunLoopObserver *(^)(<span class="built_in">NSUInteger</span>))delay;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><p>易用性体现在链式调用，这里我参考了<code>Masonry</code>，举个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (WZRunLoopObserver *(^)(<span class="built_in">NSUInteger</span>))limit &#123;</div><div class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="built_in">NSUInteger</span> limit)&#123;</div><div class="line">        _limitCount = limit;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为很多地方要用到这种返回<code>self</code>的block，所以我弄了个宏：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kRunLoopChainLockBlock(param, ...) \</span></div><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>; \</div><div class="line"><span class="keyword">return</span> ^<span class="keyword">id</span>(param)&#123; \</div><div class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(&amp;*weakSelf) <span class="keyword">self</span> = weakSelf; \</div><div class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); \</div><div class="line">__VA_ARGS__ \</div><div class="line">dispatch_semaphore_signal(_lock); \</div><div class="line"><span class="keyword">return</span> <span class="keyword">self</span>; \</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>为了防止数据抢夺，宏里使用了<code>dispatch_semaphore_t</code>给数据的操作加了锁。</p><p>功能更丰富体现在支持对任务个数的限制、缓存任务、延迟执行任务、取消任务的操作。</p><p>核心代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserverWithRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop &#123;</div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(&amp;*<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="literal">NULL</span>, kCFRunLoopBeforeWaiting, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</div><div class="line">        </div><div class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(&amp;*weakSelf) <span class="keyword">self</span> = weakSelf;</div><div class="line">        </div><div class="line">        <span class="comment">// 无任务执行</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.tasks.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// 延迟指定次数执行</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;_delay &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">self</span>-&gt;_delay--;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行任务</span></div><div class="line">        dispatch_block_t task = <span class="keyword">self</span>.tasks.firstObject;</div><div class="line">        task();</div><div class="line">        [<span class="keyword">self</span>.tasks removeObject:task];</div><div class="line">        </div><div class="line">        <span class="comment">// 添加缓存任务</span></div><div class="line">        <span class="keyword">if</span> (_isCache &amp;&amp; <span class="keyword">self</span>.caches.count) &#123;</div><div class="line">            <span class="keyword">id</span> cacheTask = <span class="keyword">self</span>.caches.firstObject;</div><div class="line">            [<span class="keyword">self</span>.tasks addObject:cacheTask];</div><div class="line">            [<span class="keyword">self</span>.caches removeObject:cacheTask];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 移除观察者</span></div><div class="line">        [<span class="keyword">self</span> removeObserver:observer];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">CFRunLoopAddObserver</span>(runloop, observer, kCFRunLoopCommonModes);</div><div class="line">    <span class="built_in">CFRelease</span>(observer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// tableView加载多张大图的情况</div><div class="line">WZRunLoopObserver.main.limit(50).cache(YES).add(^&#123;</div><div class="line">    imageView1.image = [UIImage imageWithContentsOfFile:path];</div><div class="line">&#125;).add(^&#123;</div><div class="line">    imageView2.image = [UIImage imageWithContentsOfFile:path];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>整体逻辑还是很简单的，之后我会整理下把代码传上去，大家看代码就一目了然了。当然可能自己太水会有一些隐藏的坑在里面，大家谨慎使用，重在理解思路吧😂，日后我会抽空完善~</p><p>demo:<a href="https://github.com/zhangMax/WZRunLoopObserver" target="_blank" rel="external">WZRunLoopObserver</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写的&lt;a href=&quot;http://www.wonkeyz.com/2017/07/22/Runloop-Learning-summary/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RunLoop学习总结&lt;/a&gt;文章中提到了利用 RunLoop 解决在tableView中同时加载多个大图卡顿的方案&lt;a href=&quot;https://github.com/diwu/RunLoopWorkDistribution&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RunLoopWorkDistribution&lt;/a&gt;，它的解决思路是在一次 RunLoop 时候只绘制一张图片，这样每次 RunLoop 需要处理的操作变少，从而避免卡顿。受它的启发我最近写了一个方案来解决这个问题，与其相同的也是监听每次 RunLoop 的空闲时(&lt;code&gt;kCFRunLoopBeforeWaiting&lt;/code&gt;)来完成一次任务，不同的是更加易用，支持功能更齐全，下面我来简单介绍下。&lt;br&gt;
    
    </summary>
    
    
      <category term="RunLoop" scheme="http://wonkeyz.com/tags/RunLoop/"/>
    
      <category term="卡顿" scheme="http://wonkeyz.com/tags/%E5%8D%A1%E9%A1%BF/"/>
    
  </entry>
  
  <entry>
    <title>入坑小程序</title>
    <link href="http://wonkeyz.com/2017/10/15/wxapp/"/>
    <id>http://wonkeyz.com/2017/10/15/wxapp/</id>
    <published>2017-10-15T14:23:51.000Z</published>
    <updated>2017-12-21T10:10:15.264Z</updated>
    
    <content type="html"><![CDATA[<p>有一天产品经理说咱们搞个小程序吧，程序猿：哦🙃</p><p>幸好安卓的同事提前入了坑，在他的技术分享后，我也随之入了坑。</p><p>开始我以为小程序的实现是类似React-native的，通过了解才知道在iOS上是通过<code>WKWebView</code>将<code>Html+CSS</code>呈现给用户，页面间的切换和跳转是基于原生的<code>UITabBarController</code>和<code>UINavigationController</code>，这种`native+webview的实现造就了小程序易上手、体验好的优点。<br><a id="more"></a></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>首先要有一定的前端基础（我不会告诉你我是临时抱佛脚的…），其次就是看<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/structure.html" target="_blank" rel="external">官方文档</a>和<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/demo.html?t=2017112" target="_blank" rel="external">演示demo</a>，里面写的很详细，走一遍下来再写几个demo，基本就能着手开发了，就是这么易上手。遇到问题可以去<a href="http://developers.weixin.qq.com/home?tab=1&amp;labels=&amp;lang=zh_CN&amp;token=" target="_blank" rel="external">官方社区</a>提问。</p><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>简单举几个示例</p><h3 id="通过请求加载列表"><a href="#通过请求加载列表" class="headerlink" title="通过请求加载列表"></a>通过请求加载列表</h3><p>想要显示类似UITabView的列表必须在view组件上用<code>wx:for</code>来绑定一个数组然后渲染。在.js文件中定义一个数组items<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">items</span>:[],</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>在.js文件中请求接口获取数据并赋值给items<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">items</span>:[],</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    wx.request(&#123;</div><div class="line">      <span class="attr">url</span>: Url,</div><div class="line">      <span class="attr">method</span>: <span class="string">'GET'</span>,</div><div class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">        that.setData(&#123;</div><div class="line">          <span class="attr">items</span>: res.data.result,</div><div class="line">        &#125;)</div><div class="line">      &#125;,</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>准备好数据后，就可以刷新界面了，在.wxml中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"contain"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;items&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;item.id&#125;&#125;"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这里的<code>&lt;view wx:for=&quot;&quot;&gt;</code>相当于cell，item 是默认数组元素，index是默认是索引，默认值是可以修改的，具体可以参考官方文档列表渲染。</p><p><code>wx:key</code>是用于标识view的唯一性的，可以提高列表的渲染性能。当数据改变触发渲染层重新渲染的时候，会校正带有key的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p><h3 id="添加点击事件"><a href="#添加点击事件" class="headerlink" title="添加点击事件"></a>添加点击事件</h3><p>通过<code>bintap</code>给view绑定点击事件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"contain"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;items&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;item.id&#125;&#125;"</span> <span class="attr">bindtap</span>=<span class="string">"cellAction"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p><p>然后在.js实现相应的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  cellAction()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'action'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="页面跳转、传参"><a href="#页面跳转、传参" class="headerlink" title="页面跳转、传参"></a>页面跳转、传参</h3><p>想要点击跳转某一界面，需要现在<code>app.json</code>文件在中配置，在点击方法里调用<code>navigateTo</code>方法即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  cellAction()&#123;</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'./detail'</span>,</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>如果想传参可以通过以下三种的方式：</p><h4 id="全局变量："><a href="#全局变量：" class="headerlink" title="全局变量："></a>全局变量：</h4><p>首先必须在<code>app.js</code>定义一个全局的变量，比如：globalData，然后定义一个parameter属性用于储存参数，通过<code>var app = getApp()</code>拿到app实例去获取数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">App(&#123;</div><div class="line">  <span class="attr">onLaunch</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">globalData</span>:&#123;</div><div class="line">    <span class="attr">parameter</span>:<span class="literal">null</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>参数赋值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = getApp()</div><div class="line"></div><div class="line">Page(&#123;</div><div class="line">  cellAction(object)&#123;</div><div class="line">    <span class="keyword">var</span> id = <span class="keyword">this</span>.data.items[<span class="number">0</span>].id;</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.data.items[<span class="number">0</span>].text;</div><div class="line">    app.globalData.parameter = &#123;</div><div class="line">      <span class="string">"id"</span> : id,</div><div class="line">      <span class="string">"text"</span> : text</div><div class="line">    &#125;</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'./detail'</span>,</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>获取参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// detail.js</span></div><div class="line"><span class="keyword">var</span> app = getApp()</div><div class="line">Page(&#123;</div><div class="line">  <span class="attr">onLoad</span>:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> id = app.globalData.parameter.id;</div><div class="line">    <span class="keyword">var</span> text = app.globalData.parameter.text;</div><div class="line">    <span class="built_in">console</span>.log(id);</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h4 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h4><p>就像iOS路由一样，参数通过链接传递：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  cellAction(object)&#123;</div><div class="line">    <span class="keyword">var</span> id = <span class="keyword">this</span>.data.items[<span class="number">0</span>].id;</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.data.items[<span class="number">0</span>].text;</div><div class="line">    <span class="built_in">console</span>.log(id);</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'./detail?id='</span> + id + <span class="string">'&amp;text='</span> + text,</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>到下一界面在<code>onLoad</code>函数中通过<code>options</code>获取：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// detail.js</span></div><div class="line">Page(&#123;</div><div class="line">  <span class="attr">onLoad</span>:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> id = options.id;</div><div class="line">    <span class="keyword">var</span> text = options.text;</div><div class="line">    <span class="built_in">console</span>.log(id);</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h4 id="本地缓存："><a href="#本地缓存：" class="headerlink" title="本地缓存："></a>本地缓存：</h4><p>通过<code>wx.setStorageSync</code>和<code>wx.getStorageSync</code>存取数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cellAction(object)&#123;</div><div class="line">    <span class="keyword">var</span> id = <span class="keyword">this</span>.data.items[<span class="number">0</span>].id;</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.data.items[<span class="number">0</span>].text;</div><div class="line">    wx.setStorageSync(<span class="string">"id"</span>,id);</div><div class="line">    wx.setStorageSync(<span class="string">"text"</span>,text);</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'./detail'</span>,</div><div class="line">    &#125;)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p><p>获取数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// detail.js</span></div><div class="line"><span class="keyword">var</span> app = getApp()</div><div class="line">Page(&#123;</div><div class="line">  <span class="attr">onLoad</span>:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> id = wx.getStorageSync(<span class="string">"id"</span>);</div><div class="line">    <span class="keyword">var</span> text = wx.getStorageSync(<span class="string">"text"</span>);</div><div class="line">    <span class="built_in">console</span>.log(id);</div><div class="line">    <span class="built_in">console</span>.log(text);</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>如果想传递index对应数据需要用到<code>dataset</code>：在组件中可以定义数据，这些数据将会通过事件传递给<code>SERVICE</code>。 书写方式：以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 <code>event.target.dataset</code>中会将连字符转成驼峰elementType。</p><p>我们给之前的例子定义一个参数：<code>data-index=&quot;&quot;</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"contain"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;items&#125;&#125;"</span> <span class="attr">wx:key</span>=<span class="string">"&#123;&#123;item.id&#125;&#125;"</span> <span class="attr">bindtap</span>=<span class="string">"cellAction"</span> <span class="attr">data-index</span>=<span class="string">"&#123;&#123;index&#125;&#125;"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p><p>通过<code>object.currentTarget.dataset</code>获取参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  cellAction(object)&#123;</div><div class="line">    <span class="keyword">var</span> index = object.currentTarget.dataset.index;</div><div class="line">    <span class="keyword">var</span> id = <span class="keyword">this</span>.data.items[index].id;</div><div class="line">    <span class="keyword">var</span> text = <span class="keyword">this</span>.data.items[index].text;</div><div class="line">    wx.navigateTo(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'./detail?id='</span> + id + <span class="string">'&amp;text='</span> + text,</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="动态改变样式"><a href="#动态改变样式" class="headerlink" title="动态改变样式"></a>动态改变样式</h3><p>可以通过<code>sytle</code>来接收动态样式。比如点击之后改变字体颜色：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="comment">// 定义一个字体颜色的变量</span></div><div class="line">    textColor: <span class="string">"red"</span></div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>将动态变量赋值给标签：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">bindtap</span>=<span class="string">"change"</span> <span class="attr">style</span>=<span class="string">"color: &#123;&#123;textColor&#125;&#125;"</span>&gt;</span> text <span class="tag">&lt;/<span class="name">text</span>&gt;</span></div></pre></td></tr></table></figure></p><p>点击执行change方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">change()&#123;</div><div class="line">    <span class="keyword">var</span> color = <span class="string">"green"</span></div><div class="line">    <span class="keyword">this</span>.setData(&#123;</div><div class="line">      <span class="attr">textColor</span> : color</div><div class="line">    &#125;)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p><p>先总结到这里，后续我会总结一些开发中遇到的坑，希望别太多😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一天产品经理说咱们搞个小程序吧，程序猿：哦🙃&lt;/p&gt;
&lt;p&gt;幸好安卓的同事提前入了坑，在他的技术分享后，我也随之入了坑。&lt;/p&gt;
&lt;p&gt;开始我以为小程序的实现是类似React-native的，通过了解才知道在iOS上是通过&lt;code&gt;WKWebView&lt;/code&gt;将&lt;code&gt;Html+CSS&lt;/code&gt;呈现给用户，页面间的切换和跳转是基于原生的&lt;code&gt;UITabBarController&lt;/code&gt;和&lt;code&gt;UINavigationController&lt;/code&gt;，这种`native+webview的实现造就了小程序易上手、体验好的优点。&lt;br&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://wonkeyz.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配iOS11&amp;iPhoneX的一些坑</title>
    <link href="http://wonkeyz.com/2017/09/17/Some-pits-for-iOS11-iPhoneX-adaptation/"/>
    <id>http://wonkeyz.com/2017/09/17/Some-pits-for-iOS11-iPhoneX-adaptation/</id>
    <published>2017-09-17T08:09:08.000Z</published>
    <updated>2017-11-07T08:26:58.343Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子项目开发忙成狗，就一直没做iOS11的适配，直到XcodeGM版发布后，我胸有成竹的在iPhoneX上跑起项目，整个人都凉透了…下面总结一下我遇到的坑，不是很全面，日后补充。</p><a id="more"></a><h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><h4 id="导航栏高度的变化"><a href="#导航栏高度的变化" class="headerlink" title="导航栏高度的变化"></a>导航栏高度的变化</h4><p>iOS11之前导航栏默认高度为64pt(<strong>这里高度指statusBar + NavigationBar</strong>)，iOS11之后如果设置了<code>prefersLargeTitles = YES</code>则为96pt，默认情况下还是64pt，但在iPhoneX上由于刘海的出现statusBar由以前的20pt变成了44pt，所以iPhoneX上高度变为88pt，如果项目里隐藏了导航栏加了自定义按钮之类的，这里需要注意适配一下。</p><h4 id="导航栏图层及对titleView布局的影响"><a href="#导航栏图层及对titleView布局的影响" class="headerlink" title="导航栏图层及对titleView布局的影响"></a>导航栏图层及对titleView布局的影响</h4><p>iOS11之前导航栏的title是添加在<code>UINavigationItemView</code>上面，而navigationBarButton则直接添加在<code>UINavigationBar</code>上面，如果设置了titleView，则titleView也是直接添加在<code>UINavigationBar</code>上面。iOS11之后，大概因为<code>largeTitle</code>的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在<code>_UINavigationBarContentView</code>上面，如果赋值了titleView，则会把titleView添加在<code>_UITAMICAdaptorView</code>上，而navigationBarButton被加在了<code>_UIButtonBarStackView</code>上，然后他们都被加在了<code>_UINavigationBarContentView</code>上，如图：<br><img src="http://upload-images.jianshu.io/upload_images/702870-11488fe68c9d145b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br>所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写<code>UINavigationBar</code>的<code>layoutSubviews</code>方法，调整布局，上代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line"></div><div class="line">    <span class="comment">//注意导航栏及状态栏高度适配</span></div><div class="line">    <span class="keyword">self</span>.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame), naviBarHeight);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">        <span class="keyword">if</span>([<span class="built_in">NSStringFromClass</span>([view <span class="keyword">class</span>]) containsString:<span class="string">@"Background"</span>]) &#123;</div><div class="line">            view.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([view <span class="keyword">class</span>]) containsString:<span class="string">@"ContentView"</span>]) &#123;</div><div class="line">            <span class="built_in">CGRect</span> frame = view.frame;</div><div class="line">            frame.origin.y = statusBarHeight;</div><div class="line">            frame.size.height = <span class="keyword">self</span>.bounds.size.height - frame.origin.y;</div><div class="line">            view.frame = frame;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>再补充一点，看了<a href="http://www.jianshu.com/p/26fc39135c34" target="_blank" rel="external">简书App适配iOS11</a>发现titleView支持<code>autolayout</code>，这要求titleView必须是能够自撑开的或实现了<code>- intrinsicContentSize</code>方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UILayoutFittingExpandedSize</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="继承自UIScrollView的视图偏移问题"><a href="#继承自UIScrollView的视图偏移问题" class="headerlink" title="继承自UIScrollView的视图偏移问题"></a>继承自UIScrollView的视图偏移问题</h3><p>大家在iOS11设备上运行出现最多问题应该就是<code>tableview</code>莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了<code>automaticallyAdjustsScrollViewInsets</code>属性，取而代之的是<code>UIScrollView</code>新增了<code>contentInsetAdjustmentBehavior</code>属性，这一切的罪魁祸首都是新引入的<code>safeArea</code>，关于<code>safeArea</code>适配这篇文章<a href="http://www.jianshu.com/p/efbc8619d56b" target="_blank" rel="external">iOS 11 安全区域适配总结</a>讲的很详细，感兴趣的可以看下，我直接贴适配代码，因为低版本直接用<code>contentInsetAdjustmentBehavior</code>会报警告，所有定义了如下的宏（感谢<a href="http://www.jianshu.com/u/634f3d1c7c22" target="_blank" rel="external">@炒鸡范</a>的指正，之前的宏犯了个低级错误…现改为）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define  adjustsScrollViewInsets(scrollView)\</span></div><div class="line"><span class="keyword">do</span> &#123;\</div><div class="line">_Pragma(<span class="string">"clang diagnostic push"</span>)\</div><div class="line">_Pragma(<span class="string">"clang diagnostic ignored \"-Warc-performSelector-leaks\""</span>)\</div><div class="line"><span class="keyword">if</span> ([scrollView respondsToSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"setContentInsetAdjustmentBehavior:"</span>)]) &#123;\</div><div class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="built_in">UIScrollView</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(setContentInsetAdjustmentBehavior:)];\</div><div class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];\</div><div class="line"><span class="built_in">NSInteger</span> argument = <span class="number">2</span>;\</div><div class="line">invocation.target = scrollView;\</div><div class="line">invocation.selector = <span class="keyword">@selector</span>(setContentInsetAdjustmentBehavior:);\</div><div class="line">[invocation setArgument:&amp;argument atIndex:<span class="number">2</span>];\</div><div class="line">[invocation retainArguments];\</div><div class="line">[invocation invoke];\</div><div class="line">&#125;\</div><div class="line">_Pragma(<span class="string">"clang diagnostic pop"</span>)\</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div></pre></td></tr></table></figure></p><p>还有的发现某些界面<code>tableView</code>的<code>sectionHeader</code>、<code>sectionFooter</code>高度与设置不符的问题，在iOS11中如果不实现 <code>-tableView: viewForHeaderInSection:</code>和<code>-tableView: viewForFooterInSection:</code> ，则<code>-tableView: heightForHeaderInSection:</code>和<code>- tableView: heightForFooterInSection:</code>不会被调用，导致它们都变成了默认高度，这是因为<code>tableView</code>在iOS11默认使用<code>Self-Sizing</code>，<code>tableView</code>的<code>estimatedRowHeight</code>、<code>estimatedSectionHeaderHeight</code>、 <code>estimatedSectionFooterHeight</code>三个高度估算属性由默认的0变成了<code>UITableViewAutomaticDimension</code>，解决办法简单粗暴，就是在对应界面实现对应方法或把<code>tableView</code>的这三个属性设为0。如果你想全局关闭<code>Self-Sizing</code>可使用下面这段代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedRowHeight = <span class="number">0</span>; </div><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedSectionFooterHeight = <span class="number">0</span>;</div><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedSectionHeaderHeight = <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>如果你使用了<code>Masonry</code>，某些界面需要适配需要适配<code>safeArea</code>，可以试试下面这段代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</div><div class="line">    make.edges.equalTo()(<span class="keyword">self</span>.view.safeAreaInsets)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    make.edges.equalTo()(<span class="keyword">self</span>.view)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="相册访问权限"><a href="#相册访问权限" class="headerlink" title="相册访问权限"></a>相册访问权限</h3><p>看其他适配文章上对iOS11相册权限调整的说明是“iOS11把 <a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW17" target="_blank" rel="external">NSPhotoLibraryUsageDescription</a> 替换成了<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW73" target="_blank" rel="external">NSPhotoLibraryAddUsageDescription</a>”，奇怪的是我的项目并没有添加<code>NSPhotoLibraryAddUsageDescription</code>，在访问相册时也没发生crash，后来在仔细阅读了官方文档才发现<code>NSPhotoLibraryAddUsageDescription</code>只针对相册存储权限，在iOS11上系统默认打开了用户相册的访问权限，如果应用需要存储权限就需要添加这个key，否则就会crash。</p><h3 id="AppIcon"><a href="#AppIcon" class="headerlink" title="AppIcon"></a>AppIcon</h3><p>在iOS11上发现了一个奇怪的现象，APP在启动图标会出现黑边，如图（处女座实在忍不了…）<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-23/31263530.jpg" alt="图2"><br>原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了，具体规范见<a href="https://developer.apple.com/design/" target="_blank" rel="external">Human Interface Guidelines-App Icon</a>，还是要听苹果爸爸的话啊…</p><h3 id="iPhoneX"><a href="#iPhoneX" class="headerlink" title="iPhoneX"></a>iPhoneX</h3><h4 id="LaunchImage"><a href="#LaunchImage" class="headerlink" title="LaunchImage"></a>LaunchImage</h4><p>关于iPhoneX(我就不吐槽刘海了…)，如果你的APP在iPhoneX上运行发现没有充满屏幕，上下有黑色区域，那么你应该也像我一样<code>LaunchImage</code>没有用<code>storyboard</code>而是用的<code>Assets</code>，解决办法如图，启动图的尺寸为<code>1125x2436</code>，or you can <a href="http://www.jianshu.com/p/77054dccafdb" target="_blank" rel="external">iOS开发时如何使用 Launch Screen Storyboard</a>。<br><img src="http://upload-images.jianshu.io/upload_images/702870-71705661b4518de5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p><h4 id="TabBarController"><a href="#TabBarController" class="headerlink" title="TabBarController"></a>TabBarController</h4><p>如果你使用了原生tabBar，系统会自动适配，因为我们的项目用了第三方的<code>TabBarController</code>，在iPhoneX运行，tabBar看起来怪怪的(<strong>如果不确定你的项目tabBar在iPhoneX上看起来是否正常，可以参照模拟器的照片APP，一看便知</strong>)…估计作者要等到猴年马月才适配iPhoneX，项目又着急上线，就自己改了下，主要是<code>tabBar</code>高度及<code>tabBarItem</code>偏移适配，iPhoneX由于底部安全区的原因<code>UITabBar</code>高度由49pt变成了83pt，多出来的34pt是空白手势区域。可以通过判断机型来修改相关界面代码，方式有两种，通过分辨率判断：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)</span></div></pre></td></tr></table></figure></p><p>通过设备名称判断：<br>@”iPhone10,1” : @”iPhone 8”,<br>@”iPhone10,4” : @”iPhone 8”,<br>@”iPhone10,2” : @”iPhone 8 Plus”,<br>@”iPhone10,5” : @”iPhone 8 Plus”,<br>@”iPhone10,3” : @”iPhone X”,<br>@”iPhone10,6” : @”iPhone X”,<br>这里推荐使用<a href="https://github.com/squarefrog/UIDeviceIdentifier" target="_blank" rel="external">UIDeviceIdentifier</a>。</p><p>目前遇到的就这些坑，欢迎大家指正补充~</p><p>作为一名iOS开发人员，想到当年嘲笑Android开发蛋疼的适配各种机型心情如图…<br><img src="http://upload-images.jianshu.io/upload_images/702870-4db780c96ed7f4b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>最后奉上WWDC官方视频：</p><p><a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="external">Updating Your App for iOS 11</a></p><p><a href="https://developer.apple.com/videos/play/fall2017/201/" target="_blank" rel="external">Building Apps for iPhone X</a></p><p><a href="https://developer.apple.com/videos/play/fall2017/801/" target="_blank" rel="external">Designing for iPhone X</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子项目开发忙成狗，就一直没做iOS11的适配，直到XcodeGM版发布后，我胸有成竹的在iPhoneX上跑起项目，整个人都凉透了…下面总结一下我遇到的坑，不是很全面，日后补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="适配iOS11" scheme="http://wonkeyz.com/tags/%E9%80%82%E9%85%8DiOS11/"/>
    
      <category term="适配iPhoneX" scheme="http://wonkeyz.com/tags/%E9%80%82%E9%85%8DiPhoneX/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa实践总结</title>
    <link href="http://wonkeyz.com/2017/08/20/ReactiveCocoa-common-method/"/>
    <id>http://wonkeyz.com/2017/08/20/ReactiveCocoa-common-method/</id>
    <published>2017-08-20T09:39:38.000Z</published>
    <updated>2017-12-27T13:17:24.063Z</updated>
    
    <content type="html"><![CDATA[<p>RAC是iOS开发中使用最广泛、最强大的函数响应式编程框架，有了它就不需要使用如notificarion、delegate、block、kvo等OC的离散消息传递方式，只需要考虑结果。再结合其强大的信号操作方法使用，让代码高度聚合，降低耦合性，给开发带来了很大的便利。但同时因为他的强大导致我经常忘记一些api的用法😂，下面我来简单整理下项目中用到的RAC，方便开发时查阅。<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>RAC是主要实现原理就是信号的<strong>发送</strong>和<strong>订阅</strong>，信号是RAC的构造单元，它代表我们最终将要收到的信息。当数据改变时，信号内部会发出数据，通过订阅该信号，我们可以预先写好处理逻辑，把信号与事件<strong>绑定</strong>，而不是必须等到事件发生(通常的命令式开发)。</p><p>简单的信号订阅流程如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.创建信号(默认创建冷信号,即信号数据改变时也不会触发,冷信号被订阅后变为热信号,会触发响应).</span></div><div class="line">RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 每当有订阅者订阅信号，block就会调用</span></div><div class="line">    </div><div class="line">    <span class="comment">// 2.发送信号</span></div><div class="line">    [subscriber sendNext:@<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// 还可以发送失败信号[subscriber sendError:nil];</span></div><div class="line">    <span class="comment">// 如果不再发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span></div><div class="line">    [subscriber sendCompleted];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span></div><div class="line">        </div><div class="line">        <span class="comment">// 执行完Block后，当前信号就不在被订阅了。</span></div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"信号被销毁"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 3.订阅信号,才会激活信号.</span></div><div class="line">[siganl subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">// 每当有信号发出数据，block就会调用</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"接收到数据:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p>根据上述流程及源码简单分析下<code>RACSignal</code>的底层实现：</p><p>1.创建信号siganl，首先把<code>didSubscribe</code>保存到信号中，等待被订阅；</p><p>2.当信号被订阅，即调用<code>subscribeNext:nextBlock</code>时内部会创建订阅者<code>subscriber</code>，并且把<code>nextBlock</code>保存到<code>subscriber</code>中。<code>subscribeNext</code>内部会调用siganl的<code>didSubscribe</code>；</p><p>3.siganl的<code>didSubscribe</code>中调用<code>[subscriber sendNext:@1]</code>，触发<code>nextBlock</code>回调。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="代替代理"><a href="#代替代理" class="headerlink" title="代替代理"></a>代替代理</h3><p><code>RACSubject</code>是信号提供者，它继承自<code>RACSignal</code>，同时又遵守<code>RACSubscriber</code>协议，所以它既能充当信号，也能发送信号，通常用来代替无返回值的代理，RAC封装了一个方法<code>rac_signalForSelector:subscribeNext:</code>来监听方法的调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当_loginView调用loginBtnClicked:时发送信号</span></div><div class="line">[[_loginView rac_signalForSelector:<span class="keyword">@selector</span>(loginBtnClicked:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击了登录按钮"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 当按钮背景图片改变时发送信号</span></div><div class="line">[[_btn rac_signalForSelector:<span class="keyword">@selector</span>(setBackgroundImage:)] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"改变按钮背景图片"</span>);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// tableView点击代理</span></div><div class="line">[[<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(tableView:didSelectRowAtIndexPath:) fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITableViewDelegate</span>) ] <span class="title">subscribeNext</span>:^(<span class="title">RACTuple</span> * <span class="title">x</span>) </span>&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"tableView: %@, indexPath: %@"</span>, x.first, x.second);</div><div class="line">&#125;];</div><div class="line">tableview.delegate = <span class="keyword">self</span>;</div></pre></td></tr></table></figure></p><h3 id="代替通知"><a href="#代替通知" class="headerlink" title="代替通知"></a>代替通知</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 监听键盘弹出</span></div><div class="line">[[[[<span class="built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="built_in">UIKeyboardDidShowNotification</span> object:<span class="literal">nil</span>] takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"键盘弹出:%@"</span>, x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure><p>这里注意<code>takeUntil:</code>方法，该方法会接收一个signal，当signal触发后会把之前的信号释放掉，防止信号叠加。</p><h3 id="代替KVO"><a href="#代替KVO" class="headerlink" title="代替KVO"></a>代替KVO</h3><p>有两种<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 自定义options</span></div><div class="line">[_scrollView rac_observeKeyPath:<span class="string">@"contentOffset"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> observer:<span class="literal">nil</span> block:^(<span class="keyword">id</span> value, <span class="built_in">NSDictionary</span> *change, <span class="built_in">BOOL</span> causedByDealloc, <span class="built_in">BOOL</span> affectedOnlyLastComponent) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contentOffset:%@"</span>,x);</div><div class="line">&#125;];</div><div class="line">    </div><div class="line"><span class="comment">// options默认为NSKeyValueObservingOptionInitial</span></div><div class="line">[[_scrollView rac_valuesForKeyPath:<span class="string">@"contentOffset"</span> observer:<span class="literal">nil</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"contentOffset:%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p>RAC为常用的UI控件及手势增加了分类，提供了与原生桥接的接口，方便监听事件，示例：</p><p>1.监听按钮点击事件<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[[_btn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"点击按钮:%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用RACCommand监听点击事件</span></div><div class="line">_btn.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"按钮点击%@"</span>, input);</div><div class="line">    <span class="keyword">return</span> [RACSignal empty];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p>2.监听textField文本改变</p><p>可以通过订阅<code>rac_textSignal</code>来监听textField的text改变，还可以根据需求加上一些信号操作方法，示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用filter:过滤信号,每次信号发出都会先执行过滤条件判断</span></div><div class="line">[[_textfield.rac_textSignal filter:^<span class="built_in">BOOL</span>(<span class="built_in">NSString</span>  *value) &#123;</div><div class="line">    <span class="comment">// 当条件判断等于YES的时候才会调用订阅的block</span></div><div class="line">    <span class="keyword">return</span>  value.length &gt; <span class="number">6</span>;</div><div class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    _loginBtn.enabled = <span class="literal">YES</span>;</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用ignore:忽略某些值的信号</span></div><div class="line">[[_textfield.rac_textSignal ignore:<span class="string">@"hehe"</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用skip:跳过几个信号</span></div><div class="line">[[_textfield.rac_textSignal skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,x);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>RAC把GCD封装成了<code>RACScheduler</code>，常用来做定时器使用：</p><p>1.延迟执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[[[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">    [subscriber sendNext:<span class="string">@"3"</span>];</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;] delay:<span class="number">3</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="comment">//发送信号3秒后执行这个block</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3</span> schedule:^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3s later..."</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p>这里除了使用<code>delay:</code>操作信号，还可以根据需求使用重试(<code>retry</code>)、超时(<code>timeout:</code>)、节流(<code>throttle:</code>)等方法操作信号、，不一一列举。</p><p>2.定时执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//每秒执行一次</span></div><div class="line">[[[RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler mainThreadScheduler]] takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1s"</span>);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p>加<code>takeUntil:</code>(直到信号<code>Completed</code>)是为了防止控制器释放后定时器仍执行。还可以使用<code>take:</code>（不包括信号<code>Completed/Error</code>）限制定时器执行次数。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>使用<code>RACSequence</code>集合类来对数组、字典进行遍历、筛选等操作：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 遍历字典</span></div><div class="line">[dic.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</div><div class="line">    <span class="comment">// 解包元组，会把元组的值，按顺序给参数里面的变量赋值</span></div><div class="line">    RACTupleUnpack(<span class="built_in">NSString</span> *key, <span class="built_in">NSString</span> *value) = x;</div><div class="line"></div><div class="line">    <span class="comment">// 相当于以下写法</span></div><div class="line">    <span class="comment">// NSString *key = x.first;</span></div><div class="line">    <span class="comment">// NSString *value = x.second;</span></div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,key,value); </div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 字典数组转模型数组，使用map:将字典映射成model，再将集合转换成数组</span></div><div class="line"><span class="built_in">NSArray</span> *models = [[dicArray.rac_sequence map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</div><div class="line">    <span class="keyword">return</span> [Model modelWithDict:value];</div><div class="line">&#125;] array];</div></pre></td></tr></table></figure></p><h3 id="获取多个请求数据刷新界面"><a href="#获取多个请求数据刷新界面" class="headerlink" title="获取多个请求数据刷新界面"></a>获取多个请求数据刷新界面</h3><p>使用<code>rac_liftSelector:withSignalsFromArray:</code>方法可以在信号数组中每一个信号都至少发送过一次后调用selector。可以应用在获取多个请求数据刷新界面或多个textField都有值时按钮可点击的场景：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="comment">// 模拟多请求</span></div><div class="line">    RACSignal *requestSignal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</div><div class="line">            [subscriber sendNext:<span class="string">@"请求1加载完成"</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"取消请求信号1"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    RACSignal *requestSignal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">3.0</span>];</div><div class="line">            [subscriber sendNext:<span class="string">@"请求2加载完成"</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"取消请求信号2"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(responseRequest1:request2:) withSignalsFromArray:@[signalA, signalB]];</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)responseRequest1:(<span class="keyword">id</span>)data1 request2:(<span class="keyword">id</span>)data2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, data1, data2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="宏及键值绑定"><a href="#宏及键值绑定" class="headerlink" title="宏及键值绑定"></a>宏及键值绑定</h3><p>RAC之所以强大离不开它对宏的应用和键值绑定，极大的提高了代码的简洁性，关于宏的使用可以看下<a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">Reactive Cocoa Tutorial [1] = 神奇的Macros</a>、<a href="https://halfrost.com/reactivecocoa_macro/" target="_blank" rel="external">ReactiveCocoa 中 奇妙无比的“宏”魔法</a>，大佬们讲的很详细，这里举几个项目中的简单应用。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UI与Model双向绑定</span></div><div class="line">RACChannelTo(_mobileField, text) = RACChannelTo(_resetModel, mobile);</div><div class="line"></div><div class="line"><span class="comment">// UI绑定Model</span></div><div class="line">RAC(_sendCodeBtn, enabled) = [_mobileField.rac_textSignal map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *mobile) &#123;</div><div class="line">    <span class="keyword">return</span> @([mobile isValidMobile]);</div><div class="line">&#125;];</div><div class="line"></div><div class="line"><span class="comment">// 使用combineLatest:reduce:将信号先组合再聚合返回我们需要的数据格式</span></div><div class="line">RAC(_resetBtn, enabled) = [RACSignal combineLatest:@[</div><div class="line">                                                        _mobileField.rac_textSignal,</div><div class="line">                                                        _vercodeField.rac_textSignal,</div><div class="line">                                                        _passwordField.rac_textSignal] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *mobile, <span class="built_in">NSString</span> *vercode, <span class="built_in">NSString</span> *password)&#123;</div><div class="line">                                                            <span class="keyword">return</span> @(mobile.length &gt; <span class="number">11</span> &amp;&amp; vercode.length == <span class="number">6</span> &amp;&amp; password.length &gt; <span class="number">6</span>);</div><div class="line">                                                        &#125;];</div><div class="line">                    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// @weakify()、@strongify()成对出现，防止循环引用</span></div><div class="line">@weakify(<span class="keyword">self</span>);</div><div class="line">[[<span class="keyword">self</span>.sendCodeBtn rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</div><div class="line">    @strongify(<span class="keyword">self</span>);</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.sendCodeBtn.enabled = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">self</span>.remainSeconds = <span class="number">60</span>;</div><div class="line">    <span class="keyword">self</span>.startCheckTimer = <span class="number">1</span>;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> startResendVerifyCode];</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p><p><br>目前RAC在项目中的应用就这些，因为自己也在不断摸索学习中，所以还没有大面积应用，相信只要多写，多练我也能写出大佬们那种一长串的代码😂。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>强烈推荐霜神的<a href="https://halfrost.com/tag/rac/" target="_blank" rel="external">RAC原理系列文章</a></p><p><a href="https://ming1016.github.io/2016/08/09/how-to-use-reactivecocoa/" target="_blank" rel="external">iOS函数响应式编程以及ReactiveCocoa的使用</a></p><p><a href="https://www.jianshu.com/p/87ef6720a096" target="_blank" rel="external">最快让你上手ReactiveCocoa之基础篇</a></p><p><a href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/#%E8%BF%9B%E5%85%A5-ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa 和 MVVM 入门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RAC是iOS开发中使用最广泛、最强大的函数响应式编程框架，有了它就不需要使用如notificarion、delegate、block、kvo等OC的离散消息传递方式，只需要考虑结果。再结合其强大的信号操作方法使用，让代码高度聚合，降低耦合性，给开发带来了很大的便利。但同时因为他的强大导致我经常忘记一些api的用法😂，下面我来简单整理下项目中用到的RAC，方便开发时查阅。&lt;br&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://wonkeyz.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>慎用NSLog</title>
    <link href="http://wonkeyz.com/2017/08/13/Careful-use-of-NSLog/"/>
    <id>http://wonkeyz.com/2017/08/13/Careful-use-of-NSLog/</id>
    <published>2017-08-13T08:13:29.000Z</published>
    <updated>2018-01-02T10:08:46.195Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子看了 sunnyxx 大神的<a href="http://blog.sunnyxx.com/2014/04/22/objc_dig_nslog/" target="_blank" rel="external">NSLog效率低下的原因及尝试lldb断点打印Log</a>，文中主要讲了<code>NSLog</code>对性能的消耗不容小视，吓得我赶紧搜了下，果然有滥用的情况…但是文中并没有具体说明<code>NSLog</code>的性能消耗点，于是我下载<a href="http://ftpmain.gnustep.org/pub/gnustep/core/gnustep-base-1.25.0.tar.gz" target="_blank" rel="external">GNUstep Base</a>，从<code>NSLog</code>的源码中一探究竟。<br><a id="more"></a></p><h2 id="调用步骤"><a href="#调用步骤" class="headerlink" title="调用步骤"></a>调用步骤</h2><p>看似简单一句<code>NSLog()</code>，其实内部走了几百行代码，主要分三步调用：</p><ul><li><code>NSLog(NSString* format, ...)</code></li><li><code>NSLogv(NSString* format, va_list args)</code></li><li><code>_NSLog_standard_printf_handler(NSString* message)</code></li></ul><p>我们来逐一分析下：</p><h3 id="NSLog-NSString-format-…"><a href="#NSLog-NSString-format-…" class="headerlink" title="NSLog(NSString* format, …)"></a>NSLog(NSString* format, …)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="built_in">NSString</span>* format, ...)</div><div class="line">&#123;</div><div class="line">  va_list ap;</div><div class="line"></div><div class="line">  va_start(ap, format);</div><div class="line">  <span class="built_in">NSLogv</span>(format, ap);</div><div class="line">  va_end(ap);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一步很简单，主要是获取参数列表<code>va_list ap</code>，然后调用<code>NSLogv(format, ap)</code>。</p><h3 id="NSLogv-NSString-format-va-list-args"><a href="#NSLogv-NSString-format-va-list-args" class="headerlink" title="NSLogv(NSString* format, va_list args)"></a>NSLogv(NSString* format, va_list args)</h3><p>这部就比较麻烦了，它主要做的是将我们控制台看到的 Log 的前缀及打印信息拼接，前缀包括进程、线程、时间等信息：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span>*prefix;</div><div class="line"><span class="built_in">NSString</span>              *message;</div><div class="line"><span class="built_in">NSString</span>              *threadName = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSThread</span>              *t = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span>pid = <span class="number">0</span>;</div></pre></td></tr></table></figure><p>1.进程 pid<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line"><span class="meta">#if defined(_WIN32)</span></div><div class="line">      pid = (<span class="keyword">int</span>)GetCurrentProcessId();</div><div class="line"><span class="meta">#else</span></div><div class="line">      pid = (<span class="keyword">int</span>)getpid();</div><div class="line"><span class="meta">#endif</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>2.线程 threadName<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (GSPrivateDefaultsFlag(GSLogThread) == <span class="literal">YES</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* If no name has been set for the current thread,</span></div><div class="line">     * we log the address of the NSThread object instead.</div><div class="line">     */</div><div class="line">    t = GSCurrentThread();</div><div class="line">    threadName = [t name];</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>3.打印信息 message<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1.时间</span></div><div class="line"><span class="keyword">if</span> (GSPrivateDefaultsFlag(GSLogOffset) == <span class="literal">YES</span>)</div><div class="line">&#123;</div><div class="line">   fmt = <span class="string">@"%Y-%m-%d %H:%M:%S.%F %z"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">   fmt = <span class="string">@"%Y-%m-%d %H:%M:%S.%F"</span>;</div><div class="line">&#125;</div><div class="line">cal = [[<span class="built_in">NSCalendarDate</span> calendarDate] descriptionWithCalendarFormat: fmt];</div><div class="line">    </div><div class="line">[prefix appendString: cal];</div><div class="line">[prefix appendString: <span class="string">@" "</span>];</div><div class="line"></div><div class="line"><span class="comment">// 2.进程、线程</span></div><div class="line"><span class="meta">#ifdefHAVE_SYSLOG</span></div><div class="line"><span class="keyword">if</span> (GSPrivateDefaultsFlag(GSLogSyslog) == <span class="literal">YES</span>)</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="literal">nil</span> == t)</div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[thread:%"</span>PRIuPTR<span class="string">"] "</span>,</div><div class="line">     GSPrivateThreadID()];</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nil</span> == threadName)</div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[thread:%"</span>PRIuPTR<span class="string">",%p] "</span>,</div><div class="line">     GSPrivateThreadID(), t];</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span></div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[thread:%"</span>PRIuPTR<span class="string">",%@] "</span>,</div><div class="line">     GSPrivateThreadID(), threadName];</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">   [prefix appendString: [[<span class="built_in">NSProcessInfo</span> processInfo] processName]];</div><div class="line">   <span class="keyword">if</span> (<span class="literal">nil</span> == t)</div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[%d:%"</span>PRIuPTR<span class="string">"] "</span>,</div><div class="line">        pid, GSPrivateThreadID()];</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nil</span> == threadName)</div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[%d:%"</span>PRIuPTR<span class="string">",%p] "</span>,</div><div class="line">        pid, GSPrivateThreadID(), t];</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">else</span></div><div class="line">   &#123;</div><div class="line">       [prefix appendFormat: <span class="string">@"[%d:%"</span>PRIuPTR<span class="string">",%@] "</span>,</div><div class="line">        pid, GSPrivateThreadID(), threadName];</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// 3.拼接打印信息</span></div><div class="line">  message = [[<span class="built_in">NSString</span> alloc] initWithFormat: format arguments: args];</div><div class="line">  [prefix appendString: message];</div><div class="line">  [message release];</div><div class="line">  <span class="keyword">if</span> ([prefix hasSuffix: <span class="string">@"\n"</span>] ==  <span class="literal">NO</span>)</div><div class="line">    &#123;</div><div class="line">      [prefix appendString: <span class="string">@"\n"</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == myLock)</div><div class="line">    &#123;</div><div class="line">      GSLogLock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 4.调用 _NSLog_standard_printf_handler 打印message</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">nil</span> == myLock)</div><div class="line">    &#123;</div><div class="line">      GSLogLock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  (*lockImp)(myLock, <span class="keyword">@selector</span>(lock));</div><div class="line"></div><div class="line">  _NSLog_printf_handler(prefix);</div><div class="line"></div><div class="line">  (*unlockImp)(myLock, <span class="keyword">@selector</span>(unlock));</div></pre></td></tr></table></figure></p><p>为了保证信息的准确性，第4步在调用<code>_NSLog_printf_handler()</code>时加了递归锁<code>NSRecursiveLock</code>，对锁感兴趣请见<a href="http://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="external">iOS 中的八大锁</a>。</p><h3 id="NSLog-standard-printf-handler-NSString-message"><a href="#NSLog-standard-printf-handler-NSString-message" class="headerlink" title="_NSLog_standard_printf_handler(NSString* message)"></a>_NSLog_standard_printf_handler(NSString* message)</h3><p>这个方法根据不同的环境调用对应的输出函数，定义了一下变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="built_in">NSData</span>*d;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>*buf;</div><div class="line">  <span class="keyword">unsigned</span>len;</div><div class="line"><span class="meta">#ifdefined(_WIN32)</span></div><div class="line">  LPCWSTRnull_terminated_buf;</div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="meta">#ifdefined(HAVE_SYSLOG) || defined(HAVE_SLOGF)</span></div><div class="line">  <span class="keyword">char</span>*null_terminated_buf = <span class="literal">NULL</span>;</div><div class="line"><span class="meta">#endif</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">  <span class="keyword">static</span> <span class="built_in">NSStringEncoding</span> enc = <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>接下来将<code>message</code>转成<code>buffer</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (enc == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    enc = [<span class="built_in">NSString</span> defaultCStringEncoding];</div><div class="line">  &#125;</div><div class="line">d = [message dataUsingEncoding: enc allowLossyConversion: <span class="literal">NO</span>];</div><div class="line"><span class="keyword">if</span> (d == <span class="literal">nil</span>)</div><div class="line">  &#123;</div><div class="line">    d = [message dataUsingEncoding: <span class="built_in">NSUTF8StringEncoding</span></div><div class="line">allowLossyConversion: <span class="literal">NO</span>];</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (d == <span class="literal">nil</span>)<span class="comment">// Should never happen.</span></div><div class="line">  &#123;</div><div class="line">    buf = [message lossyCString];</div><div class="line">    len = strlen(buf);</div><div class="line">  &#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    buf = (<span class="keyword">const</span> <span class="keyword">char</span>*)[d bytes];</div><div class="line">    len = [d length];</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>最后根据不同系统调用对应打印函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifdefined(_WIN32)</span></div><div class="line">  null_terminated_buf = UNISTR(message);</div><div class="line"></div><div class="line">  OutputDebugStringW(null_terminated_buf);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> ((GSPrivateDefaultsFlag(GSLogSyslog) == <span class="literal">YES</span></div><div class="line">    || write(_NSLogDescriptor, buf, len) != (<span class="keyword">int</span>)len) &amp;&amp; !IsDebuggerPresent())</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">static</span> HANDLE eventloghandle = <span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!eventloghandle)</div><div class="line">&#123;</div><div class="line">  eventloghandle = RegisterEventSourceW(<span class="literal">NULL</span>,</div><div class="line">    UNISTR([[<span class="built_in">NSProcessInfo</span> processInfo] processName]));</div><div class="line">&#125;</div><div class="line">      <span class="keyword">if</span> (eventloghandle)</div><div class="line">&#123;</div><div class="line">  ReportEventW(eventloghandle,<span class="comment">// event log handle</span></div><div class="line">    EVENTLOG_WARNING_TYPE,<span class="comment">// event type</span></div><div class="line">    <span class="number">0</span>,<span class="comment">// category zero</span></div><div class="line">    <span class="number">0</span>,<span class="comment">// event identifier</span></div><div class="line">    <span class="literal">NULL</span>,<span class="comment">// no user security identifier</span></div><div class="line">    <span class="number">1</span>,<span class="comment">// one substitution string</span></div><div class="line">    <span class="number">0</span>,<span class="comment">// no data</span></div><div class="line">    &amp;null_terminated_buf,<span class="comment">// pointer to string array</span></div><div class="line">    <span class="literal">NULL</span>);<span class="comment">// pointer to data</span></div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#else</span></div><div class="line"></div><div class="line"><span class="meta">#ifdefined(HAVE_SYSLOG)</span></div><div class="line">  <span class="keyword">if</span> (GSPrivateDefaultsFlag(GSLogSyslog) == <span class="literal">YES</span></div><div class="line">    || write(_NSLogDescriptor, buf, len) != (<span class="keyword">int</span>)len)</div><div class="line">    &#123;</div><div class="line">      null_terminated_buf = malloc(<span class="keyword">sizeof</span> (<span class="keyword">char</span>) * (len + <span class="number">1</span>));</div><div class="line">      strncpy (null_terminated_buf, buf, len);</div><div class="line">      null_terminated_buf[len] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">      syslog(SYSLOGMASK, <span class="string">"%s"</span>,  null_terminated_buf);</div><div class="line"></div><div class="line">      free(null_terminated_buf);</div><div class="line">    &#125;</div><div class="line"><span class="meta">#elif defined(HAVE_SLOGF)</span></div><div class="line">  <span class="keyword">if</span> (GSPrivateDefaultsFlag(GSLogSyslog) == <span class="literal">YES</span></div><div class="line">    || write(_NSLogDescriptor, buf, len) != (<span class="keyword">int</span>)len)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* QNX's slog has a size limit per entry. We might need to iterate over</span></div><div class="line">       * _SLOG_MAXSIZEd chunks of the buffer</div><div class="line">       */</div><div class="line">      <span class="keyword">const</span> <span class="keyword">char</span> *newBuf = buf;</div><div class="line">      <span class="keyword">unsigned</span> newLen = len;</div><div class="line"></div><div class="line">      <span class="comment">// Allocate at most _SLOG_MAXSIZE bytes</span></div><div class="line">      null_terminated_buf = malloc(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * MIN(newLen, _SLOG_MAXSIZE));</div><div class="line">      <span class="comment">// If it's shorter than that, we never even enter the loop</span></div><div class="line">      <span class="keyword">while</span> (newLen &gt;= _SLOG_MAXSIZE)</div><div class="line">        &#123;</div><div class="line">          strncpy(null_terminated_buf, newBuf, (_SLOG_MAXSIZE - <span class="number">1</span>));</div><div class="line">          null_terminated_buf[_SLOG_MAXSIZE] = <span class="string">'\0'</span>;</div><div class="line">          slogf(_SLOG_SETCODE(_SLOG_SYSLOG, <span class="number">0</span>), _SLOG_ERROR, <span class="string">"%s"</span>,</div><div class="line">            null_terminated_buf);</div><div class="line">          newBuf += (_SLOG_MAXSIZE - <span class="number">1</span>);</div><div class="line">          newLen -= (_SLOG_MAXSIZE - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">/* Write out the rest (which will be at most (_SLOG_MAXSIZE - 1) chars,</span></div><div class="line">       * so the terminator still fits.</div><div class="line">       */</div><div class="line">      <span class="keyword">if</span> (<span class="number">0</span> != newLen)</div><div class="line">        &#123;</div><div class="line">          strncpy(null_terminated_buf, newBuf, newLen);</div><div class="line">          null_terminated_buf[newLen] = <span class="string">'\0'</span>;</div><div class="line">          slogf(_SLOG_SETCODE(_SLOG_SYSLOG, <span class="number">0</span>), _SLOG_ERROR, <span class="string">"%s"</span>,</div><div class="line">            null_terminated_buf);</div><div class="line">        &#125;</div><div class="line">      free(null_terminated_buf);</div><div class="line">    &#125;</div><div class="line"><span class="meta">#else</span></div><div class="line">  write(_NSLogDescriptor, buf, len);</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure></p><p>默认情况下调用<code>write(_NSLogDescriptor, buf, len)</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真是一看源码吓一跳啊，一句<code>NSLog</code>里藏了这么多操作…以后还是慎用<code>NSLog</code>，多用<code>lldb</code>(<a href="https://casatwy.com/shi-yong-lldbdiao-shi-cheng-xu.html" target="_blank" rel="external">使用LLDB调试程序</a>)大法吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子看了 sunnyxx 大神的&lt;a href=&quot;http://blog.sunnyxx.com/2014/04/22/objc_dig_nslog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSLog效率低下的原因及尝试lldb断点打印Log&lt;/a&gt;，文中主要讲了&lt;code&gt;NSLog&lt;/code&gt;对性能的消耗不容小视，吓得我赶紧搜了下，果然有滥用的情况…但是文中并没有具体说明&lt;code&gt;NSLog&lt;/code&gt;的性能消耗点，于是我下载&lt;a href=&quot;http://ftpmain.gnustep.org/pub/gnustep/core/gnustep-base-1.25.0.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GNUstep Base&lt;/a&gt;，从&lt;code&gt;NSLog&lt;/code&gt;的源码中一探究竟。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>堆对象与栈对象</title>
    <link href="http://wonkeyz.com/2017/08/11/Heap-and-stack/"/>
    <id>http://wonkeyz.com/2017/08/11/Heap-and-stack/</id>
    <published>2017-08-11T05:58:15.000Z</published>
    <updated>2018-02-01T01:41:06.641Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一次组内讨论时，大家被一个很基础的问题难住了，就是OC对象为什么存储在堆上？存在栈上会怎么样？大家给的答案都模棱两可，看来基础知识还是不扎实啊…这篇文章就来简单总结一下堆与栈。</p><h2 id="堆与栈概念"><a href="#堆与栈概念" class="headerlink" title="堆与栈概念"></a>堆与栈概念</h2><p>两者都是进程中的一段内存区域，先来看下基本概念：</p><ul><li>堆（heap）：堆是向高地址扩展的数据结构，是不连续的内存区域，堆分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。它由<strong>程序员</strong>分配和释放，用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用alloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被剔除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置。<a id="more"></a></li><li>栈（stack）：栈是向低地址扩展的数据结构，是一块连续的内存的区域。它由<strong>编译器</strong>自动分配并释放，用于存放局部变量、占用空间确定的数据。也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上将我们可以把栈看成一个临时数据寄存、交换的内存区。</li></ul><h2 id="堆对象与栈对象"><a href="#堆对象与栈对象" class="headerlink" title="堆对象与栈对象"></a>堆对象与栈对象</h2><p>讲完概念我们来举例看一下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 栈</span></div><div class="line"><span class="built_in">NSInteger</span> i = <span class="number">233</span>;</div><div class="line"><span class="comment">// 栈</span></div><div class="line"><span class="built_in">NSString</span> *s = <span class="string">@"stack"</span>;</div><div class="line"></div><div class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure></p><p>前两个不必说，第三行创建了一个NSObject类型的指针obj和一个 NSObject类型的对象，因为指针的大小确定，所以obj指针存储在栈上，而其指向的对象内存无法确定，所以存储在堆上（即堆对象）。</p><p>那么对象就只能存储在堆上吗？目前Objective-C不支持直接在栈上创建对象（栈对象），但可以通过如下方式间接创建：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> &#123;</div><div class="line">    Class isa;</div><div class="line">&#125; fakeNSObject;</div><div class="line"></div><div class="line">fakeNSObject.isa = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSObject</span> *obj = (__bridge <span class="built_in">NSObject</span> *)&amp;fakeNSObject;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [obj description]);</div><div class="line"></div><div class="line"><span class="comment">// 输出 &lt;NSObject: 0x1066eadc8&gt; 得知存放于栈中</span></div></pre></td></tr></table></figure></p><p>所以栈对象也是存在的，那么就回到了开头的问题，对象为何不存储在栈上呢？</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>既然有了栈对象，那么我们来看下它会有哪些优缺点吧：</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>创建效率：因为栈是操作系统提供的数据结构，系统会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。相比动态分配的堆对象，栈对象内存的申请、分配效率要高得多。</p></li><li><p>管理简单、安全：栈对象的生命周期是确定的，对象出栈以后就会被释放，不会存在内存泄漏，但这同时也是栈对象的最大缺点。每个线程的栈相互独立，所以栈对象是线程安全的。而一个进程的所有线程共有这些堆，所以对堆对象的操作要考虑同步和互斥的问题。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p>空间限制：前面讲到栈是一块连续的内存区域，所以栈的容量大小是系统预先设定好的，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">512 KB (secondary threads)</div><div class="line">8 MB (OS X main thread)</div><div class="line">1 MB (iOS main thread)</div></pre></td></tr></table></figure><p>因此对象如果都在栈上创建不太现实，而堆只要物理内存不告警可以无限制使用。</p></li><li>生命周期不可控：Objective-C变量有效范围是由 “{}” 包含的块来决定的，也就是说栈对象的生命周期仅限于其所在的块里，出了块立马会被释放。一个对象被创建以后有可能会通过方法调用传递到别的方法，当栈对象的创建方法返回时，栈对象会被一起 pop 出栈而释放，导致其没法在别处被继续持有。此时 retain 操作会失效，除非用 copy 方法在想持有该栈对象的地方重新拷贝一份属于自己的栈对象。因此，栈对象会给对象的内存管理造成相当大的麻烦。</li></ul><p>通过这几点比较，不难看出对象存储在堆中是有道理的~</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>其实OC中是有栈对象的，那就是block，这也是为什么我们在使用block时要注意很多点，比如想持有一个block要用<code>copy</code>将block从栈拷贝到堆上。</p><p>前面提到栈对象的有效区域仅限于其所在的块内，所以在MRC环境下，下面代码会有问题：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^BasicBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="keyword">void</span> someFunction() &#123;</div><div class="line">    BasicBlock block;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(condition) &#123;</div><div class="line">        block = ^ &#123; ... &#125;;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        block = ^ &#123; ... &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    block();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 正确写法</span></div><div class="line"><span class="keyword">void</span> someFunction() &#123; </div><div class="line">    BasicBlock block; </div><div class="line">    <span class="keyword">if</span>(condition) &#123; </div><div class="line">        block = Block_copy(^ &#123; ... &#125;); </div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line">        block = Block_copy(^ &#123; ... &#125;); </div><div class="line">    &#125; </div><div class="line">    </div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>因为ARC环境下，一旦Block赋值就会触发copy，<strong>block就会copy到堆上，这种情况是`</strong>NSMallocBlock<code>。ARC环境下也是存在</code><strong>NSStackBlock`的时候，这种情况下，</strong>block就在栈上。</strong></p><p><strong>MRC环境下，只有copy，<strong>block才会被复制到堆上，否则，</strong>block一直都在栈上，是<code>__NSStackBlock</code>。</strong>详见<a href="https://halfrost.com/ios_block/" target="_blank" rel="external">深入研究 Block 捕获外部变量和 __block 实现原理</a>。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-15-stack-and-heap-objects-in-objective-c.html" target="_blank" rel="external">Stack and Heap Objects in Objective-C</a></p><p><a href="https://www.cnblogs.com/aibangxiansheng/p/5961830.html" target="_blank" rel="external">iOS开发中的内存分配（堆和栈）</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/11/stack.html" target="_blank" rel="external">Stack的三种含义</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在一次组内讨论时，大家被一个很基础的问题难住了，就是OC对象为什么存储在堆上？存在栈上会怎么样？大家给的答案都模棱两可，看来基础知识还是不扎实啊…这篇文章就来简单总结一下堆与栈。&lt;/p&gt;
&lt;h2 id=&quot;堆与栈概念&quot;&gt;&lt;a href=&quot;#堆与栈概念&quot; class=&quot;headerlink&quot; title=&quot;堆与栈概念&quot;&gt;&lt;/a&gt;堆与栈概念&lt;/h2&gt;&lt;p&gt;两者都是进程中的一段内存区域，先来看下基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆（heap）：堆是向高地址扩展的数据结构，是不连续的内存区域，堆分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。它由&lt;strong&gt;程序员&lt;/strong&gt;分配和释放，用于存放进程运行中被动态分配的内存段，它大小并不固定，可动态扩张或缩减。当进程调用alloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用realse释放内存时，被释放的内存从堆中被剔除（堆被缩减），因为我们现在iOS基本都使用ARC来管理对象，所以不用我们程序员来管理，但是我们要知道这个对象存储的位置。
    
    </summary>
    
    
      <category term="内存" scheme="http://wonkeyz.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>GCD的一些坑</title>
    <link href="http://wonkeyz.com/2017/08/05/pit-of-GCD/"/>
    <id>http://wonkeyz.com/2017/08/05/pit-of-GCD/</id>
    <published>2017-08-05T10:02:59.000Z</published>
    <updated>2017-12-20T03:15:59.400Z</updated>
    
    <content type="html"><![CDATA[<p>开发中我们用到最多的实现多线程方式就是GCD了，用多了遇到的坑也就多，下面我来总结一些使用GCD时可能遇到的坑和注意点，以防万一。</p><h2 id="GCD与AutoreleasePool"><a href="#GCD与AutoreleasePool" class="headerlink" title="GCD与AutoreleasePool"></a>GCD与AutoreleasePool</h2><p>我们知道在使用<code>NSThread</code>时，需要在线程调度方法中手动添加<code>AutoreleasePool</code>，防止内存泄漏，那么GCD需要吗？答案是不，因为在主线程和GCD中的线程，都默认拥有自动释放池。每次执行事件循环时，就会将其清空。</p><a id="more"></a><h2 id="dispatch-once-t必须是全局或static变量"><a href="#dispatch-once-t必须是全局或static变量" class="headerlink" title="dispatch_once_t必须是全局或static变量"></a>dispatch_once_t必须是全局或static变量</h2><p>在单例中我们会用到<code>dispatch_once_t</code>，一般都是通过Xcode自带的snippet敲出来的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>值得注意的是<code>static</code>关键字，它确保了<code>dispatch_once_t</code>只有一个实例，从而使block只执行一次，所以如果哪天自己手敲的时候别忘了它。</p><p>尽量少用<code>dispatch_once</code>，就像尽量少用NSObject的类方法<code>initialize()</code>和<code>(void)load</code>，它会带来难以排查的bug。</p><h2 id="dispatch-time-t"><a href="#dispatch-time-t" class="headerlink" title="dispatch_time_t"></a>dispatch_time_t</h2><p>在创建<code>dispatch_after</code>及<code>dispatch_timer</code>时会用到<code>dispatch_time(dispatch_time_t when, int64_t delta);</code>，第一个参数是什么时候开始，一般用<code>DISPATCH_TIME_NOW</code>，第二个参数是时间间隔，系统给了以下几种常量，注意单位均是纳秒：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每秒有多少纳秒</span></div><div class="line"><span class="meta">#define NSEC_PER_SEC 1000000000ull</span></div><div class="line"><span class="comment">// 每毫秒有多少纳秒</span></div><div class="line"><span class="meta">#define NSEC_PER_MSEC 1000000ull</span></div><div class="line"><span class="comment">// 每秒有多少微秒</span></div><div class="line"><span class="meta">#define USEC_PER_SEC 1000000ull</span></div><div class="line"><span class="comment">// 每微秒有多少纳秒</span></div><div class="line"><span class="meta">#define NSEC_PER_USEC 1000ull</span></div></pre></td></tr></table></figure></p><p>所以分别用它们来表示1秒这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span></div><div class="line"><span class="built_in">NSEC_PER_MSEC</span> * <span class="built_in">NSEC_PER_USEC</span></div><div class="line">USEC_PER_SEC * <span class="built_in">NSEC_PER_USEC</span></div></pre></td></tr></table></figure></p><h2 id="dispatch-source-t"><a href="#dispatch-source-t" class="headerlink" title="dispatch_source_t"></a>dispatch_source_t</h2><p>官方给出的创建<code>dispatch_source_t</code>的代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">dispatch_source_t CreateDispatchTimer(uint64_t interval,</div><div class="line">              uint64_t leeway,</div><div class="line">              <span class="built_in">dispatch_queue_t</span> queue,</div><div class="line">              dispatch_block_t block)</div><div class="line">&#123;</div><div class="line">   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,</div><div class="line">                                                     <span class="number">0</span>, <span class="number">0</span>, queue);</div><div class="line">   <span class="keyword">if</span> (timer)</div><div class="line">   &#123;</div><div class="line">      dispatch_source_set_timer(timer, dispatch_walltime(<span class="literal">NULL</span>, <span class="number">0</span>), interval, leeway);</div><div class="line">      dispatch_source_set_event_handler(timer, block);</div><div class="line">      dispatch_resume(timer);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> timer;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>有几点需要注意：</p><ul><li><code>dispatch_source_t</code>是间隔定时器，也就是说每隔一段时间间隔定时器就会触发。在<code>NSTimer</code>中要做到同样的效果需要手动把<code>repeats</code>设置为<code>YES</code>。</li><li><code>dispatch_source_set_timer</code>中第二个参数，当我们使用<code>dispatch_time</code>或者<code>DISPATCH_TIME_NOW</code>时，系统会使用默认时钟来进行计时。然而当系统休眠的时候，默认时钟是不走的，也就会导致计时器停止。使用<code>dispatch_walltime</code>可以让计时器按照真实时间间隔进行计时。</li><li><code>dispatch_source_set_timer</code>的第四个参数<code>leeway</code>指的是一个期望的容忍时间，将它设置为 1 秒，意味着系统有可能在定时器时间到达的前 1 秒或者后 1 秒才真正触发定时器。在调用时推荐设置一个合理的<code>leeway</code>值。需要注意，就算指定<code>leeway</code>值为 0，系统也无法保证完全精确的触发时间，只是会尽可能满足这个需求。</li><li>event handler block中的代码会在指定的queue中执行。当queue是后台线程的时候，<code>dispatch_source_t</code>相比<code>NSTimer</code>就好操作一些了。因为<code>NSTimer</code>是需要<code>Runloop</code>支持的，如果要在后台queue中使用，则需要手动添加Runloop。</li><li><code>dispatch_source_set_event_handler</code>这个函数在执行完之后，block会立马执行一遍，后面隔一定时间间隔再执行一次。而 <code>NSTimer</code>第一次执行是到计时器触发之后。这也是和<code>NSTimer</code>之间的一个显著区别。</li></ul><h3 id="停止timer"><a href="#停止timer" class="headerlink" title="停止timer"></a>停止timer</h3><p>停止<code>dispatch_source_t</code>有两种方法，一种是使用<code>dispatch_suspend</code>，另外一种是使用<code>dispatch_source_cancel</code>。</p><p><code>dispatch_suspend</code>严格上只是把timer暂时挂起，它和<code>dispatch_resume</code>是一个平衡调用，<strong>两者分别会减少和增加dispatch对象的挂起计数。当这个计数大于 0 的时候，timer就会执行。在挂起期间，产生的事件会积累起来，等到resume的时候会融合为一个事件发送</strong>。</p><p>需要注意的是，dispatch source并没有提供用于检测source本身的挂起计数的 API，也就是说外部不能得知一个source当前是不是挂起状态，在设计代码逻辑时需要考虑到这一点。</p><p><code>dispatch_source_cancel</code>则是真正意义上的取消timer。被取消之后如果想再次执行timer，只能重新创建新的timer。这个过程类似于对<code>NSTimer</code>执行<code>invalidate</code>。</p><p>关于取消timer，另外一个很重要的注意事项，<code>dispatch_suspend</code>之后的timer，是不能被释放的！下面的代码会引起崩溃：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stopTimer &#123;</div><div class="line">    dispatch_suspend(_timer);</div><div class="line">    _timer = <span class="literal">nil</span>; <span class="comment">// EXC_BAD_INSTRUCTION 崩溃</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因此使用<code>dispatch_suspend</code>时，timer本身的实例需要一直保持。使用<code>dispatch_source_cancel</code>则没有这个限制：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stopTimer &#123;</div><div class="line">    dispatch_source_cancel(_timer);</div><div class="line">    _timer = <span class="literal">nil</span>; <span class="comment">// OK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>先来看下官方对它的说明:<code>Schedule a block for execution on a given queue at a specified time</code>，这意味着<code>dispatch_after</code>是将block<strong>延迟添加</strong>到队列中，而不是<strong>延迟执行</strong>。示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dispatch_time_t delayTime3 = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>*<span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">dispatch_time_t delayTime2 = dispatch_time(DISPATCH_TIME_NOW, <span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line"></div><div class="line">dispatch_after(delayTime3, mainQueue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"3秒之后添加到队列"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_after(delayTime2, mainQueue, ^&#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"2秒之后添加到队列"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div><div class="line"></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">26.367321</span> GCDTest[<span class="number">10342</span>:<span class="number">171487</span>] current task</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">26.367583</span> GCDTest[<span class="number">10342</span>:<span class="number">171487</span>] next task</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">28.552447</span> GCDTest[<span class="number">10342</span>:<span class="number">171487</span>] <span class="number">2</span>秒之后添加到队列</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">29.369393</span> GCDTest[<span class="number">10342</span>:<span class="number">171487</span>] <span class="number">3</span>秒之后添加到队列</div></pre></td></tr></table></figure></p><p>从输出中可以看出是延迟添加，所以如果你想要精确控制执行顺序，那么要慎用<code>dispatch_after</code>咯~</p><h2 id="dispatch-suspend与dispatch-resume"><a href="#dispatch-suspend与dispatch-resume" class="headerlink" title="dispatch_suspend与dispatch_resume"></a>dispatch_suspend与dispatch_resume</h2><p>GCD提供了暂停/挂起(<code>dispatch_suspend</code>)与恢复(<code>dispatch_resume</code>)队列上的任务的功能（<strong>不支持对系统默认创建全局队列、主队列的操作</strong>）。<strong>但这里的暂停并不是指立刻暂停队列上运行的block，而是等当前运行的block结束后，再暂停队列，恢复后继续执行</strong>，示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="comment">//提交第一个block，延时5秒打印。</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds..."</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//提交第二个block，也是延时5秒打印</span></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">5</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"After 5 seconds again..."</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//延时一秒</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sleep 1 second..."</span>);</div><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</div><div class="line"><span class="comment">//挂起队列</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"suspend..."</span>);</div><div class="line">dispatch_suspend(queue);</div><div class="line"></div><div class="line"><span class="comment">//延时10秒</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sleep 10 second..."</span>);</div><div class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test resume 1"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//恢复队列</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"resume..."</span>);</div><div class="line">dispatch_resume(queue);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test resume 2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//输出为：</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">39.067920</span> GCDTest[<span class="number">28453</span>:<span class="number">667453</span>] sleep <span class="number">1</span> second...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">40.068305</span> GCDTest[<span class="number">28453</span>:<span class="number">667453</span>] suspend...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">40.068544</span> GCDTest[<span class="number">28453</span>:<span class="number">667453</span>] sleep <span class="number">10</span> second...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">44.073200</span> GCDTest[<span class="number">28453</span>:<span class="number">668668</span>] After <span class="number">5</span> seconds...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">50.070099</span> GCDTest[<span class="number">28453</span>:<span class="number">667453</span>] resume...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">55.071913</span> GCDTest[<span class="number">28453</span>:<span class="number">668668</span>] After <span class="number">5</span> seconds again...</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">55.072092</span> GCDTest[<span class="number">28453</span>:<span class="number">668668</span>] test resume <span class="number">1</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">13</span>:<span class="number">29</span>:<span class="number">55.072246</span> GCDTest[<span class="number">28453</span>:<span class="number">668668</span>] test resume <span class="number">2</span></div></pre></td></tr></table></figure></p><p>所有使用<code>dispatch_suspend</code>时要注意咯~详见<a href="http://blog.csdn.net/zhangyingeios/article/details/73250620" target="_blank" rel="external">dispatch_suspend 与 dispatch_resume探索</a>。</p><h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p><code>dispatch_apply</code>在给定的队列上多次执行某一任务，它不会立刻返回，而是在执行完block中的任务后才会返回，是同步执行的函数。<strong>在主线程直接调用会阻塞主线程去执行block中的任务</strong>，为了不阻塞主线程，一般把<code>dispatch_apply</code>放在异步队列中调用，执行完成后通知主线程。示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line"><span class="built_in">dispatch_async</span>(globalQueue, ^&#123;</div><div class="line">   <span class="built_in">dispatch_queue_t</span> applyQueue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">   <span class="comment">//第一个参数，3--block执行的次数</span></div><div class="line">   <span class="comment">//第二个参数，applyQueue--block任务提交到的队列</span></div><div class="line">   <span class="comment">//第三个参数，block--需要重复执行的任务</span></div><div class="line">   dispatch_apply(<span class="number">3</span>, applyQueue, ^(size_t index) &#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"current index %@"</span>,@(index));</div><div class="line">          sleep(<span class="number">1</span>);</div><div class="line">   &#125;);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"dispatch_apply 执行完成"</span>);</div><div class="line"></div><div class="line">   <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line">   <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"回到主线程更新UI"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div><div class="line"></div><div class="line"><span class="comment">//输出：</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">15.192467</span> GCDTest[<span class="number">32639</span>:<span class="number">763148</span>] current task</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">15.193226</span> GCDTest[<span class="number">32639</span>:<span class="number">763148</span>] next task</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">15.193245</span> GCDTest[<span class="number">32639</span>:<span class="number">763480</span>] current index <span class="number">0</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">15.193252</span> GCDTest[<span class="number">32639</span>:<span class="number">763466</span>] current index <span class="number">1</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">15.193261</span> GCDTest[<span class="number">32639</span>:<span class="number">763545</span>] current index <span class="number">2</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">16.194556</span> GCDTest[<span class="number">32639</span>:<span class="number">763480</span>] dispatch_apply 执行完成</div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">30</span>:<span class="number">16.194792</span> GCDTest[<span class="number">32639</span>:<span class="number">763148</span>] 回到主线程更新UI</div></pre></td></tr></table></figure></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁：两个（多个）线程都要等待对方完成某个操作才能进行下一步，这时就会发生死锁。<br>以下几种情况会产生死锁，需要注意一下：</p><ul><li><p>主线程串行队列同步执行任务，在主线程运行时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line"><span class="built_in">dispatch_sync</span>(mainQueue,^&#123;</div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">"MainQueue"</span>);            </div><div class="line">&#125;);</div></pre></td></tr></table></figure></li><li><p>自定义串行队列嵌套执行同步任务(并发队列不会造成死锁)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"me.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;   <span class="comment">//该代码段后面的代码都不会执行，程序被锁定在这里</span></div><div class="line">  <span class="built_in">NSLog</span>(<span class="string">@"会执行的代码"</span>);</div><div class="line">  <span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"代码不执行"</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li><li><p>嵌套使用<code>dispatch_apply</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"me.test.gcd"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_apply(<span class="number">3</span>, queue, ^(size_t i) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current index %@"</span>,@(i));</div><div class="line">dispatch_apply(<span class="number">3</span>, queue, ^(size_t j) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current index %@"</span>,@(j));</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//只会执行一次current index 1</span></div></pre></td></tr></table></figure></li></ul><h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h2><p>当我们需要同时执行多个任务，在所有任务完成后汇总结果时可以使用<code>dispatch_group</code>(队列组)，先看下基本用法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"current task"</span>);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"并行任务1"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"并行任务2"</span>);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(groupQueue, mainQueue, ^&#123;</div><div class="line">      <span class="built_in">NSLog</span>(<span class="string">@"group中的任务都执行完成,回到主线程更新UI"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"next task"</span>);</div></pre></td></tr></table></figure></p><p>我们可以通过<code>dispatch_group_wait</code>给gorup设置超时时限，但需要注意的是<code>dispatch_group_wait</code>是同步的所以不能放在主线程执行，否则会发生阻塞。</p><p>还有一种添加任务的方式是通过<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>，它们必须成对出现，通常在无法访问到队列变量时使用，如使用AFNetworking添加多个异步任务时：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</div><div class="line"></div><div class="line">dispatch_group_t group = dispatch_group_create();  </div><div class="line"><span class="comment">//Enter group</span></div><div class="line">dispatch_group_enter(group);</div><div class="line">[manager GET:<span class="string">@"http://www.baidu.com"</span> parameters:<span class="literal">nil</span> success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</div><div class="line">    <span class="comment">//Deal with result...</span></div><div class="line">    <span class="comment">//Leave group</span></div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;    failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="comment">//Deal with error...</span></div><div class="line">    <span class="comment">//Leave group</span></div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;];</div><div class="line"><span class="comment">//More request...</span></div></pre></td></tr></table></figure></p><p>更多解读请见：<a href="http://blog.csdn.net/u011103194/article/details/50248807" target="_blank" rel="external">dispatch_group_enter的学习</a>、<a href="http://www.jianshu.com/p/228403206664" target="_blank" rel="external">使用dispatch_group来进行线程同步</a>。</p><h2 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h2><p>相关方法：</p><ul><li><code>dispatch_semaphore_create(long value)</code>：方法接收一个long类型的参数, 返回一个<code>dispatch_semaphore_t</code>类型的信号量，值为传入的参数；</li><li><code>dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</code>：接收一个信号和时间值，若信号的信号量为0，则会阻塞当前线程，直到信号量大于0或者经过输入的时间值；若信号量大于0，则会使信号量减1并返回，程序继续住下执行；</li><li><code>dispatch_semaphore_signal(dispatch_semaphore_t dsema)</code>：使信号量加1并返回。</li></ul><p>使用信号量可以做到线程同步：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</div><div class="line">        </div><div class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    i = <span class="number">100</span>;</div><div class="line">    dispatch_semaphore_signal(semaphore);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"i = %zd"</span>, i);</div><div class="line"></div><div class="line"><span class="comment">// 输出为i = 0</span></div></pre></td></tr></table></figure></p><p>因为是将block异步添加到一个并行队列里面，所以程序在主线程跃过block直接到<code>dispatch_semaphore_wait</code>这一行，因为semaphore信号量为0，时间值为DISPATCH_TIME_FOREVER，所以当前线程会一直阻塞，直到block在子线程执行到<code>dispatch_semaphore_signal</code>，使信号量+1，此时semaphore信号量为1了，所以程序继续往下执行。这就保证了线程间同步了。</p><p>还可以做线程锁：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">        </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">     <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">          <span class="comment">// 相当于加锁</span></div><div class="line">          dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"i = %zd semaphore = %@"</span>, i, semaphore);</div><div class="line">          <span class="comment">// 相当于解锁</span></div><div class="line">          dispatch_semaphore_signal(semaphore);</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当线程1执行到<code>dispatch_semaphore_wait</code>这一行时，semaphore的信号量为1，所以使信号量-1变为0，并且线程1继续往下执行；如果当在线程1 NSLog这一行代码还没执行完的时候，又有线程2来访问，执行<code>dispatch_semaphore_wait</code>时由于此时信号量为0，且时间为<code>DISPATCH_TIME_FOREVER</code>，所以会一直阻塞线程2（此时线程2处于等待状态），直到线程1执行完NSLog并执行完<code>dispatch_semaphore_signal</code>使信号量为1后，线程2才能解除阻塞继续住下执行。这样就起到了线程锁的作用。</p><h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p><code>dispatch_barrier_async</code>的作用就是向某个队列插入一个block，当目前正在执行的block运行完成后，阻塞这个block后面添加的block，只运行这个block直到完成，然后再继续后续的任务。</p><p>值得注意的是：<code>dispatchbarrier\(a)sync</code>只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样，所以要小心别死锁！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.dullgrass.com/2015/11/19/iOS%E4%B8%ADGCD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/" target="_blank" rel="external">iOS中GCD的使用小结</a><br><a href="http://tutuge.me/2015/04/03/something-about-gcd/" target="_blank" rel="external">GCD使用经验与技巧浅谈</a><br><a href="https://knightsj.github.io/2017/01/13/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E8%AE%B2%E8%A7%A3%E7%9A%84iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF-GCD/" target="_blank" rel="external">浅显易懂讲解iOS多线程技术-GCD</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发中我们用到最多的实现多线程方式就是GCD了，用多了遇到的坑也就多，下面我来总结一些使用GCD时可能遇到的坑和注意点，以防万一。&lt;/p&gt;
&lt;h2 id=&quot;GCD与AutoreleasePool&quot;&gt;&lt;a href=&quot;#GCD与AutoreleasePool&quot; class=&quot;headerlink&quot; title=&quot;GCD与AutoreleasePool&quot;&gt;&lt;/a&gt;GCD与AutoreleasePool&lt;/h2&gt;&lt;p&gt;我们知道在使用&lt;code&gt;NSThread&lt;/code&gt;时，需要在线程调度方法中手动添加&lt;code&gt;AutoreleasePool&lt;/code&gt;，防止内存泄漏，那么GCD需要吗？答案是不，因为在主线程和GCD中的线程，都默认拥有自动释放池。每次执行事件循环时，就会将其清空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="GCD" scheme="http://wonkeyz.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>在对象dealloc时做一些操作</title>
    <link href="http://wonkeyz.com/2017/07/28/Do-some-operation-with%20-object-dealloc/"/>
    <id>http://wonkeyz.com/2017/07/28/Do-some-operation-with -object-dealloc/</id>
    <published>2017-07-28T06:53:00.000Z</published>
    <updated>2017-10-19T07:14:06.505Z</updated>
    
    <content type="html"><![CDATA[<p>最近做直播间优化时遇到个奇葩需求，需要在评论输入视图释放时做一些操作，当时没想太多直接在CommentView外部公开一个block，然后在CommentView的<code>dealloc</code>方法里调用该block，简单粗暴…<a id="more"></a>事后想了想能不能封装一个通用的方法给对象添加一个释放时调用的block呢？第一时间想到用Method Swizzling来hook对象的<code>dealloc</code>方法，马上领悟到这样未免侵入性太强，日后也许会导致难以排查的bug，仔细思考后想到了一个巧妙的方法，通过Category给<code>NSObject</code>公开一个添加block的方法，利用runtime的AssociatedObject给对象搭配一个‘‘小伙伴’’，在对象释放时，这个‘‘小伙伴’’负责调用block，这样既做到了与对象的共存亡又简单干净，上代码~<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^DeallocBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Associate</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">给对象添加释放时调用的block</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)addDeallocBlock:(DeallocBlock)deallocBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"NSObject+Associate.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Partner</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) DeallocBlock deallocBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Partner</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (_deallocBlock) &#123;</div><div class="line">        _deallocBlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *kPartnerArrayKey = &amp;kPartnerArrayKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Associate</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addDeallocBlock:(DeallocBlock)deallocBlock &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *partnerArray = objc_getAssociatedObject(<span class="keyword">self</span>, kPartnerArrayKey);</div><div class="line">        <span class="keyword">if</span> (!partnerArray) &#123;</div><div class="line">            partnerArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, kPartnerArrayKey, partnerArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">        &#125;</div><div class="line">        Partner *partner = [[Partner alloc] init];</div><div class="line">        partner.deallocBlock = deallocBlock;</div><div class="line">        [partnerArray addObject:partner];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>这里有几点<strong>注意事项</strong>：<br>1.block触发时的线程与对象释放时的线程一致，注意后续操作的线程安全。<br>2.如果你想在block里引用对象，那么无论强弱引用都是不可行的，强引用会造成循环引用，弱引用则获取不到对象，因为已经被至为nil，可以使用<code>__unsafe_unretained</code>修饰：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) unsafeSelf = <span class="keyword">self</span>;</div></pre></td></tr></table></figure></p><p>现在看起来比最开始的直接在CommentView的dealloc里做操作的想法成熟多了，但之后我再查阅相关资料时还是发现自己<em>too young too native</em>了…其实早就有大佬写了类似的框架，放个链接供大家膜<a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor#%E4%BD%BF%E7%94%A8cyldeallocblockexecutor" target="_blank" rel="external">CYLDeallocBlockExecutor</a>，代码不是很复杂，但是考虑的点和实现思路很赞，也许这就是差距吧…其中涉及到了<code>NSHashTable</code>，不了解的可以看南大的<a href="http://southpeak.github.io/2015/05/10/ios-techset-1/" target="_blank" rel="external">iOS知识小集 第1期(2015.05.10)-NSHashTable部分</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做直播间优化时遇到个奇葩需求，需要在评论输入视图释放时做一些操作，当时没想太多直接在CommentView外部公开一个block，然后在CommentView的&lt;code&gt;dealloc&lt;/code&gt;方法里调用该block，简单粗暴…
    
    </summary>
    
    
      <category term="runitme" scheme="http://wonkeyz.com/tags/runitme/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop学习总结</title>
    <link href="http://wonkeyz.com/2017/07/22/Runloop-Learning-summary/"/>
    <id>http://wonkeyz.com/2017/07/22/Runloop-Learning-summary/</id>
    <published>2017-07-22T03:31:16.000Z</published>
    <updated>2017-12-13T05:36:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇总结了<code>Runtime</code>的知识点，这篇就顺便来看下它的同姓兄弟<code>RunLoop</code>吧~</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>RunLoop</code>直译过来就是一直在跑的循环。也许平时我们很少用它，但是APP的运行离不开它，当APP启动时，会启动一个主线程，并启动主线程的<code>RunLoop</code>，<code>RunLoop</code>会不断循环使程序一直运行，并监听用户的各种操作，然后把消息分发给线程来处理；当线程空闲时，<code>RunLoop</code>还会让线程进入睡眠状态，达到省电的效果。这种模式被称为<strong>事件驱动模型</strong>，伪代码如下：<br><a id="more"></a><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;  </div><div class="line">    <span class="keyword">while</span> (AppIsRunning) &#123;  </div><div class="line">        <span class="keyword">id</span> whoWakesMe = SleepForWakingUp;  </div><div class="line">        <span class="keyword">id</span> event = GetEvent(whoWakesMe);  </div><div class="line">        HandleEvent(event);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注：每个线程都自己的<code>RunLoop</code>，它们一一对应，但只有主线程的是默认开启的，其他子线程需要<strong>在线程内部</strong>调用<code>[NSRunLoop currentRunLoop]</code>来获取<code>RunLoop</code>，在第一次获取时就会创建<code>RunLoop</code>，当线程结束时<code>RunLoop</code>随之销毁。<br>再来看下一张大家很熟悉的图，取自<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">官网</a>:<br><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="NSRunLoop事件驱动模型"></p><p><code>RunLoop</code>就是中间的黄圈（是不是很形象🤣），右边是<code>RunLoop</code>需要接收的源事件，接收后调用相应的事件处理方法。我们来简单看一下这两个源：</p><h3 id="Input-Source-输入源"><a href="#Input-Source-输入源" class="headerlink" title="Input Source 输入源"></a>Input Source 输入源</h3><p>输入源包括三种:<code>NSPort</code>、<code>自定义源</code>、<code>performSelector:OnThread:delay</code>。它用来投递异步消息，通常消息来自其他线程或者程序。在接受到消息并调用指定的方法时，线程对应的<code>RunLoop</code>对象会通过执行<code>runUntilDate:</code>方法来退出。</p><h4 id="NSPort"><a href="#NSPort" class="headerlink" title="NSPort"></a>NSPort</h4><p><code>NSPort</code>是描述通讯信道的抽象类(source1)。只需要简单的创建端口对象，并使用<code>NSPort</code>的方法将端口对象加入到<code>RunLoop</code>，端口对象会处理创建以及配置输入源。<br><code>NSPort</code>分三种：<code>NSMessagePort</code>（基本废弃）、<code>NSMachPort</code>、 <code>NSSocketPort</code>。<code>NSMachPort</code>可以作为<a href="https://www.cnblogs.com/samyangldora/p/4631815.html" target="_blank" rel="external">线程之间的通讯通道</a>。<br>系统中的<code>NSURLConnection</code>是基于<code>NSSocketPort</code>进行通信的，所以当在子线程中使用<code>NSURLConnection</code>时，需要手动启动<code>RunLoop</code>, 因为子线程中的<code>RunLoop</code>默认是没有启动的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLConnection</span> *connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</div><div class="line">[connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">[connection start];</div></pre></td></tr></table></figure></p><h4 id="Custom"><a href="#Custom" class="headerlink" title="Custom"></a>Custom</h4><p>可以使用<code>CFRunLoopSourceRef</code>类型相关的函数来创建自定义输入源，接着使用回调函数来配置输入源。<code>Core Fundation</code>会在恰当的时候调用回调函数，处理输入事件以及清理源。常见的触摸、滚动事件等就是该类源，由系统内部实现，基本用不到。</p><h4 id="performSelector-OnThread"><a href="#performSelector-OnThread" class="headerlink" title="performSelector:OnThread:"></a>performSelector:OnThread:</h4><p>苹果提供了可以在任一线程执行selector的输入源，常用方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主线程</span></div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</div><div class="line"><span class="comment">// 指定线程</span></div><div class="line">performSelector:onThread:withObject:waitUntilDone:</div><div class="line">performSelector:onThread:withObject:waitUntilDone:modes:</div><div class="line"><span class="comment">// 针对当前线程</span></div><div class="line">performSelector:withObject:afterDelay:         </div><div class="line">performSelector:withObject:afterDelay:inModes:</div><div class="line"><span class="comment">// 取消在当前线程执行和上面两个方法对应</span></div><div class="line">cancelPreviousPerformRequestsWithTarget:</div><div class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</div></pre></td></tr></table></figure></p><p>这些selector执行的条件是当前线程的<code>RunLoop</code>处于启动状态。<br>和端口源一样，这些selector的请求会在目标线程中加入到<code>queue</code>中序列化，以减缓线程中多个方法执行带来的同步问题。<br>官方文档说<code>selector</code>会在执行完成后会被移出<code>RunLoop</code>，但经测试只有<code>performSelector:withObject:afterDelay:</code>会移除，因为它是timer源。<br>还有一点要注意我们平时用的<code>performSelector:(SEL)aSelector</code>方法与线程无关，它是同步执行的，不会添加到<code>RunLoop</code>中。  </p><h3 id="Timer-Source-时间源"><a href="#Timer-Source-时间源" class="headerlink" title="Timer Source 时间源"></a>Timer Source 时间源</h3><p><code>Timer sources</code>在预设的时间点唤醒<code>RunLoop</code>同步的给线程发送事件，是线程通知自己做某事的一种方式。常用的方法有：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</div><div class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti invocation:(<span class="built_in">NSInvocation</span> *)invocation repeats:(<span class="built_in">BOOL</span>)yesOrNo;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector withObject:(<span class="keyword">id</span>)anArgument afterDelay:(<span class="built_in">NSTimeInterval</span>)delay inModes:(<span class="built_in">NSArray</span> *)modes;</div><div class="line"></div><div class="line">+ (<span class="built_in">CADisplayLink</span> *)displayLinkWithTarget:(<span class="keyword">id</span>)target selector:(SEL)sel;</div><div class="line">- (<span class="keyword">void</span>)addToRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSString</span> *)mode;</div><div class="line">- (<span class="keyword">void</span>)removeFromRunLoop:(<span class="built_in">NSRunLoop</span> *)runloop forMode:(<span class="built_in">NSRunLoopMode</span>)mode;</div></pre></td></tr></table></figure></p><p>有几点需要注意：<br><code>scheduledTimerWithTimeInterval:</code>创建的timer会自动以<code>NSDefaultRunLoopMode</code>模式加载到当前<code>RunLoop</code>中，而其他方法创建的则需要手动调用<code>[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];</code>添加到<code>RunLoop</code>中。<br>当<code>repates</code>为NO时，timer在执行完成时，会从<code>RunLoop</code>中移除，当为YES时，timer会一直保存在当前<code>RunLoop</code>中，直到<code>invalidated</code>方法调用。<br>因为<code>NSTimer</code>是基于<code>RunLoop</code>的，所以它不是实时的，会有误差。因为<code>RunLoop</code>只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次。其实所有定时器都是都不是绝对精确的，具体分析见<a href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/" target="_blank" rel="external">更可靠和高精度的 iOS 定时器</a>。</p><h2 id="CFRunLoop"><a href="#CFRunLoop" class="headerlink" title="CFRunLoop"></a>CFRunLoop</h2><p>相信你和我一样，看了上面的还是云里雾里的，感觉<code>RunLoop</code>并没有多强大，看来还是了解的不够深入，那么我们就来看下<code>NSRunLoop</code>的底层实现<a href="https://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.h.auto.html" target="_blank" rel="external">CFRunLoop</a>。它的数据结构如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; </div><div class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           </div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上一张sunnyxx大神的CFRunLoop构成图：<img src="http://owgqmweju.bkt.clouddn.com/17-12-10/16351272.jpg" alt="CFRunLoop构成"><br>从图中可以看出RunLoop与Thread一一对应，一个RunLoop有n个Mode，每个Mode有n个Source/Timer/Observer。<strong>但在每次调用RunLoop的主函数时，只能指定其中一个Mode（<code>CFRunLoopRunSpecific</code>函数），这个Mode被称作<code>currentMode</code>。如果需要切换Mode，只能退出Loop，重启新的Loop</strong>。这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响。我们从下往上看：</p><h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p><code>CFRunLoopSourceRef</code>是<code>RunLoop</code>的数据源抽象类，有两个版本：Source0和Source1。</p><ul><li>Source0是非基于port的，包含了一个回调，不能主动触发事件。它负责App内部事件，由App负责管理触发，例如UIEvent、UITouch事件。使用时，你需要先调用<code>CFRunLoopSourceSignal(source)</code>，将这个Source标记为待处理，然后手动调用<code>CFRunLoopWakeUp(runloop)</code>来唤醒<code>RunLoop</code>，让其处理这个事件。</li><li>Source1是基于port的，包含了一个<a href="https://segmentfault.com/a/1190000002400329" target="_blank" rel="external">mach_port</a>和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。它能主动唤醒RunLoop，接收系统分发事件。</li></ul><h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><p><code>CFRunLoopTimerRef</code>是基于时间的触发器，它包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。上面提到的Timer Source中的方法都是基于<code>CFRunLoopTimerRef</code>的封装，</p><p>Source1和Timer都属于端口事件源，不同的是所有的Timer都共用一个端口(Timer Port)，而每个Source1都有不同的对应端口。<br>Source0属于Input Source中的一部分，Input Source还包括cuntom自定义源，由其他线程手动发出。</p><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p>它用来监听<code>RunLoop</code>当前的状态，每个Observer都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接收到这个变化。可以观察的状态有以下几点：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</div><div class="line">    kCFRunLoopEntry         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>你可以在<code>RunLoop</code>中观察一个或多个状态，观察者也可以设置是否只观察一次或者重复多次观察，如果只观察一次，那么调用回调函数以后，观察者就自动被移除了。<br>上代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建observer</span></div><div class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(), kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----监听到RunLoop状态发生改变---%zd"</span>, activity);</div><div class="line">&#125;);</div><div class="line"><span class="comment">//参数1：分配内存 参数2：要监听哪个runloop状态的标记 参数3：是否重复。这个observer是只调用一次还是runloop每次循环都调 参数4：优先级，一般传0</span></div><div class="line"></div><div class="line"><span class="comment">// 添加观察者到RunLoop</span></div><div class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);   </div><div class="line"></div><div class="line"><span class="comment">// 释放observer</span></div><div class="line"><span class="built_in">CFRelease</span>(observer);</div></pre></td></tr></table></figure></p><p>上面的Source/Timer/Observer被统称为mode item，<strong>每个item可以同时加入多个mode，但一个item被重复加入同一个mode无效，如果一个mode中一个item都没有，RunLoop就会立即退出</strong>。  </p><h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h3><p><code>CFRunLoopMode</code>的代码结构如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</div><div class="line">    <span class="built_in">CFStringRef</span> _name;            </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    </div><div class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    </div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; </div><div class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    </div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>可以从中看出上面提到的一个Mode可以对应多个item的结构，系统定义了以下几种Mode：  </p><ul><li>NSRunLoopDefaultMode: 默认Mode，也是空闲状态。主线程通常在这Mode下运行。</li><li>UITrackingRunLoopMode: 界面跟踪Mode，ScrollView滚动时候的模式，保证界面滑动时不受其他Mode影响。</li><li>UIInitializationRunLoopMode: 在刚启动程序时进入的第一个Mode，私有，启动完成后就不再使用。</li><li>NSRunLoopCommonModes: 这是一组可配置的通用模式，默认包括了第1和第2种模式，可以添加自己的Mode。</li></ul><p>更多Mode请见<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="external">这里</a>。  </p><p>常见的应用比如我们在滑动scrollView时，从开始滑动到结束滑动，系统就把主线程的RunLoopMode由<code>NSRunLoopDefaultMode</code>切换到<code>UITrackingRunLoopMode</code>再到<code>NSRunLoopDefaultMode</code>，这也是iOS列表滑动流畅的秘密之一。<br>再比如我们在开发中会发现当列表滑动时timer触发的事件不会被执行，原因是使用<code>scheduledTimerWithTimeInterval</code>方法创建的timer会已<code>NSRunLoopDefaultMode</code>加入到<code>RunLoop</code>中，但在滑动时Mode被切换成了<code>UITrackingRunLoopMode</code>，<strong>ModeItem要在对应的Mode下才会被<code>RunLoop</code>处理</strong>，所以如果想在滑动时不影响timer的执行可以使用以下代码创建timer，让timer在两个Mode中都能回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span></div><div class="line">                                             target:<span class="keyword">self</span></div><div class="line">                                           selector:<span class="keyword">@selector</span>(timerTick:)</div><div class="line">                                           userInfo:<span class="literal">nil</span></div><div class="line">                                            repeats:<span class="literal">YES</span>];</div><div class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div></pre></td></tr></table></figure></p><p>Mode暴露的管理mode item的接口有下面几个：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</div><div class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</div><div class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</div></pre></td></tr></table></figure></p><p>你只能通过modeName来操作内部的mode，当你传入一个新的modeName但RunLoop内部没有对应mode时，RunLoop会自动帮你创建对应的<code>CFRunLoopModeRef</code>。对于一个RunLoop来说，其内部的mode只能增加不能删除。</p><h3 id="RunLoop的睡眠与唤醒"><a href="#RunLoop的睡眠与唤醒" class="headerlink" title="RunLoop的睡眠与唤醒"></a>RunLoop的睡眠与唤醒</h3><p>在App运行时，在Debug栏里按下暂停，会出现以下堆栈<img src="http://owgqmweju.bkt.clouddn.com/17-12-11/38340739.jpg" alt=""><br>这就是<code>RunLoop</code>的睡眠状态，与前面提到的MachPort有关，图片里面上边的两个<code>mach_msg</code>函数会指定一个端口发给内核一个消息，此时<code>RunLoop</code>就是正在等待接收信息的状态，也就是等待唤醒，内核此刻将其挂起（不是传统意义的挂起，还在内存里，其实就是睡眠状态，等待有人叫醒，类似于NSNotificationCenter,在收到Post时唤醒进行处理）过程如下：</p><ul><li>指定用于唤醒的<code>mach_port</code>端口；</li><li>调用<code>mach_msg</code>监听唤醒端口，被唤醒前，系统内核将此线程挂起，停留在<code>mach_msg_trap</code>状态；</li><li>由另一个线程（或另一个进程中的某个线程）向内核发送这个端口的msg后，trap状态被唤醒，RunLoop继续运行；  </li></ul><h3 id="RunLoop循环逻辑"><a href="#RunLoop循环逻辑" class="headerlink" title="RunLoop循环逻辑"></a>RunLoop循环逻辑</h3><p>看完了<code>RunLoop</code>的结构，我们来看下<code>RunLoop</code>到底是怎么工作的。<br>先来看下两个执行<code>RunLoop</code>的函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用DefaultMode启动</span></div><div class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OK，找到源头了，就是<code>CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle)</code>函数，其内部就是do-while循环，由于代码太多，我们直接看下执行过程的简述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1 通知观察者runLoop已经启动(DoObserver)</div><div class="line">2 记录RunLoop启动事件,并设定RunLoop运行的超时条件</div><div class="line"></div><div class="line">---- RunLoop进入循环 ----</div><div class="line"></div><div class="line">3 通知观察者任何即将要开始的timer(DoObserver)</div><div class="line">4 通知观察着任何即将启动的source0(DoObserver)</div><div class="line">5 调用RunLoopMode的blocks链中的block方法(DoBlocks)</div><div class="line">6 启动任何准备好的非基于端口的source0源(DoSource0)</div><div class="line">7 调用RunLoopMode的blocks链中的block方法(DoBlocks)</div><div class="line">8 检查MachPort端口是否有消息要处理，如果有立即进入步骤12</div><div class="line">9 如果没有消息处理,通知观察者线程进入休眠(DoObserver)</div><div class="line"></div><div class="line">---- RunLoop休眠----</div><div class="line"></div><div class="line">10 将线程至于休眠直到任意下面的事件发生(调用`mach_msg`使RunLoop休眠)</div><div class="line">    A.source1事件</div><div class="line">    B.timer启动</div><div class="line">    C.runLoop自身超时时间到了</div><div class="line">    D.被其他调用者手动唤醒</div><div class="line"></div><div class="line">11 通知观察者线程将被唤醒(DoObserver)</div><div class="line">12 处理未处理的事件(有dispatchPort显示是哪个port的事件需要处理)</div><div class="line">    A.如果livePort为NULL,啥都不做(会跳出循环)</div><div class="line">    B.如果livePort是wakeUpPort,说明RunLoop运行超时(会跳出循环)</div><div class="line">    C.如果livePort是timerPort,说明timerSource启动(DoTimers),进入步骤3</div><div class="line">    D.如果livePort是dispatchPort,说明系统的libDispatch向主线程送消息,会调dispatch_async(dispatch_get_main_queue(),block)</div><div class="line">    E.如果livePort是其他port,通过mach_msg取出回调,处理事件(DoSource1), 进入步骤3</div><div class="line">    </div><div class="line">---- RunLoop退出循环 ----</div><div class="line"></div><div class="line">13 通知观察者runLoop结束</div></pre></td></tr></table></figure></p><h2 id="Cocoa中RunLoop的应用"><a href="#Cocoa中RunLoop的应用" class="headerlink" title="Cocoa中RunLoop的应用"></a>Cocoa中RunLoop的应用</h2><p>我们先看下APP启动后的状态：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CFRunLoop</span> &#123;</div><div class="line">    current mode = kCFRunLoopDefaultMode</div><div class="line">    common modes = &#123;</div><div class="line">        <span class="built_in">UITrackingRunLoopMode</span></div><div class="line">        kCFRunLoopDefaultMode</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    common mode items = &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// source0 (manual)</span></div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventSignalCallback &#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</div><div class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// source1 (mach port)</span></div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventCallback&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</div><div class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</div><div class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>b03,</div><div class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</div><div class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</div><div class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Ovserver</span></div><div class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></div><div class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</div><div class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _afterCACommitHandler&#125;</div><div class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Timer</span></div><div class="line">        <span class="built_in">CFRunLoopTimer</span> &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</div><div class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</div><div class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    modes ＝ &#123;</div><div class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</div><div class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = (null),</div><div class="line">            observers = &#123;</div><div class="line">                <span class="built_in">CFRunLoopObserver</span> &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</div><div class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">            )&#125;,</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = &#123;</div><div class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line">        </div><div class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</div><div class="line">            sources0 = (null),</div><div class="line">            sources1 = (null),</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>AutoReleasePool是Apple中清理临时变量，释放内容的机制，在app的main函数中，所有的内容都是包裹在一个AutoReleasePool中的。在APP启动后，Apple在RunLoop中注册三个RunLoopObserver，其回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>:</p><ul><li>第一个RunLoopObserver监听<code>kCFRunLoopEntry</code>状态，callback函数中会自动创建autoReleasePool，其优先级最高，保证应用启动后所有的操作都在autoreleasePool中运行。</li><li>第二个RunLoopObserver监听<code>kCFRunLoopBeforeWaiting</code>状态，在此时autoreleasePool会释放旧的池(<code>_objc_autoreleasePoolPop()</code>)，并创建一个新的autoreleasePool(<code>_objc_autoreleasePoolPush()</code>)。</li><li>第三个RunLoopObserver关注<code>kCFRunLoopExit</code>状态，此时释放autoreleasePool，其优先级最低，保证其释放池子发生在其他所有回调之后。  </li></ul><p>比如下面这段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Person.m</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personInitWithName:(<span class="built_in">NSString</span> *)name&#123;</div><div class="line"><span class="comment">//MRC内存管理原则：谁创建谁释放</span></div><div class="line">    Person *person = [[[Person alloc]init]autorelease];<span class="comment">//自动释放池 延时释放</span></div><div class="line">    person.name = name;</div><div class="line">    <span class="keyword">return</span> person;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">vc.m</div><div class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span>)Person *person1;</div><div class="line">- (<span class="keyword">void</span>)viewDidLoad&#123;</div><div class="line">    ........ </div><div class="line">    <span class="keyword">self</span>.person1 = [Person personInitWithName:<span class="string">@"name1"</span>];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="keyword">self</span>.person1.name);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">IBAction</span>)clicked:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"person.name:%@"</span>,<span class="keyword">self</span>.person1.name);<span class="comment">//MRC下点击按钮后报野指针错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>MRC内存管理原则：谁创建谁释放。在执行完<code>viewDidLoad</code>后<code>RunLoop</code>进入睡眠状态，旧池被释放，person对象随之释放，在点击事件发生时，<code>RunLoop</code>被唤醒，创建新池，所以此时会报错。</p><p>那么平时哪里可以用到<code>autoreleasepool</code>呢?</p><ul><li>使用<code>NSThread</code>做多线程开发时，需要在线程调度方法中手动添加自动释放池，否则可能会发生内存泄露，后面介绍AFN时会提到。</li><li>当循环中创建了大量临时对象，建议使用自动释放池，用来减少高内存占用。如：</li></ul><p>想了解更多可以看下<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">sunny大神的autorelease</a></p><h3 id="事件响应与手势识别"><a href="#事件响应与手势识别" class="headerlink" title="事件响应与手势识别"></a>事件响应与手势识别</h3><p>RunLoop解释了为何iOS应用能够接受到屏幕触摸等事件。在APP启动后，Apple在RunLoop中注册了一个Source1（基于Mach Port）用来接收系统事件，其回调函数为<code>__IOHIDEventSystemClientQueueCallback()</code>。  </p><p>当一个点击事件发生以后，IOKit会生成一个IOHIDEvent事件，并由系统层面的SpringBoard接受按键(锁屏/静音)、触摸、加速、接近传感器等几种Event，然后通过进程间通信的mach port发送给当前App的main RunLoop，然后在DoSource1中，source1的回调会触发，内部会调用系统<code>_UIApplicationHandleEventQueue()</code>进行事件分发。</p><p><code>_UIApplicationHandleEventQueue()</code>方法会把IOHIDEvent处理并包装成常见的UIEvent事件进行处理或分发，其中包括识别UIGesture/处理屏幕旋转/发送给UIWindow等，通常事件比如UIButton点击/touchesBegin/Move/End/Cancel等事件都是在这个Source1回调中完成。</p><p>当上面的<code>_UIApplicationHandleEventQueue()</code>识别了一个手势时，其首先会调用Cancel将当前的touchesBegin/Move/End系列回调打断。随后系统将对应的UIGestureRecognizer标记为待处理。</p><p>苹果注册了一个Observer监测BeforeWaiting(Loop即将进入休眠)事件，这个Observer的回调函数是<code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer的回调。</p><p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作UI时，比如改变了Frame、更新了UIView/CALayer的层次时，或者手动调用了UIView/CALayer的setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(Loop即将进入休眠)和 Exit(即将退出Loop)事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的UIView/CAlayer以执行实际的绘制和调整，并更新UI界面。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用NSObject的<code>performSelecter:afterDelay:</code>/<code>performSelector:onThread:</code>后，实际上其内部会创建一个Timer并添加到当前线程的RunLoop中。所以如果当前线程没有RunLoop，则这个方法会失效。</p><h3 id="GCD与RunLoop"><a href="#GCD与RunLoop" class="headerlink" title="GCD与RunLoop"></a>GCD与RunLoop</h3><p>当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取得这个block，并在回调<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code>里执行这个 block。但这个逻辑仅限于dispatch切到主线程，dispatch到其他线程仍然是由libDispatch处理的。</p><h2 id="RunLoop的应用举例"><a href="#RunLoop的应用举例" class="headerlink" title="RunLoop的应用举例"></a>RunLoop的应用举例</h2><p><code>RunLoop</code>为Apple做了那么多重要的事，那么它能给我们实际开发中带来什么呢？<br>举一个简单的需求，怎样避免tableView在滑动时加载图片造成的卡顿？答案是把加载图片的代码放到<code>NSDefaultRunLoopMode</code>中执行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) withObject:downloadedImage afterDelay:<span class="number">0</span> inModes:@[<span class="built_in">NSDefaultRunLoopMode</span>]];</div></pre></td></tr></table></figure></p><p>还有我们熟悉的<code>AFNetworking</code>也用到了<code>RunLoop</code>，<code>AFURLConnectionOperation</code>这个类是基于<code>NSURLConnection</code>构建的，所以它必须要<code>RunLoop</code>去驱动，代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">// 注册线程</span></div><div class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</div><div class="line">        <span class="comment">// 添加Port防止RunLoop退出</span></div><div class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</div><div class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</div><div class="line">        [runLoop run];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</div><div class="line">        _networkRequestThread =</div><div class="line">        [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></div><div class="line">                                selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:)</div><div class="line">                                  object:<span class="literal">nil</span>];</div><div class="line">        [_networkRequestThread start];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _networkRequestThread;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这种创建一个常驻线程的思路值得学习。</p><p>还有比较著名的框架ASDk，它把界面排版、绘制放在后台执行，利用<code>RunLoop</code>闲时去主线程更新界面，从而时保持界面的流畅，具体细节请见<a href="https://draveness.me/asdk-rendering" target="_blank" rel="external">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a>。</p><p>解决在tableView中同时加载多个大图卡顿的问题，方案见<a href="https://github.com/diwu/RunLoopWorkDistribution" target="_blank" rel="external">RunLoopWorkDistribution</a></p><p>监控App卡顿<a href="https://github.com/suifengqjn/PerformanceMonitor" target="_blank" rel="external">PerformanceMonitor</a></p><h2 id="NSRunLoop"><a href="#NSRunLoop" class="headerlink" title="NSRunLoop"></a>NSRunLoop</h2><p>最后我们回到原点，总结一下<code>NSRunLoop</code>的使用方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Mode为默认的NSDefaultRunLoopMode模式，没有超时限制</span></div><div class="line">- (<span class="keyword">void</span>)run;</div><div class="line"></div><div class="line"><span class="comment">// Mode为默认的NSDefaultRunLoopMode模式，参数为运时间期限</span></div><div class="line">- (<span class="keyword">void</span>)runUntilDate:(<span class="built_in">NSDate</span> *)limitDate;</div><div class="line"></div><div class="line"><span class="comment">// 自定义RunLoop Mode、时间期限</span></div><div class="line">- (<span class="built_in">BOOL</span>)runMode:(<span class="built_in">NSString</span> *)mode beforeDate:(<span class="built_in">NSDate</span> *)limitDate;</div></pre></td></tr></table></figure></p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><ul><li>循环一旦开启，就关闭不了，并且之后的代码就无法执行。api文档中提到：如果没有输入源和定时源加入到runloop中，runloop就马上退出，否则通过频繁调用<code>-runMode:beforeDate:</code>方法来让runloop运行在NSDefaultRunLoopMode模式下。但是，<strong>人为地移除输入源、timer不能保证runloop会退出</strong>，因为系统有可能会自己添加一些源来处理事件。（下面两种方法也是）</li><li>无法用CFRunLoopStop(runloopRef)退出，这种方式启动的runloop不利于控制，不建议使用</li></ul><h3 id="runUntilDate"><a href="#runUntilDate" class="headerlink" title="runUntilDate:"></a>runUntilDate:</h3><ul><li>运行在<code>NSDefaultRunLoopMode</code>模式，有超时时间限制。它实际上也是不断调用<code>-runMode:beforeDate:</code>方法来让runloop运行在<code>NSDefaultRunLoopMode</code>模式下，直到到达超时时间。调用<code>CFRunLoopStop(runloopRef)</code>无法停止RunLoop的运行。为什么呢..因为这个方法只会结束当前<code>-runMode:beforeDate:</code>的调用，之后的<code>-runMode:beforeDate:</code>该调用的还是会继续。。。直到timeout。</li><li>对应<code>CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)</code>。</li></ul><h3 id="runMode-beforeDate"><a href="#runMode-beforeDate" class="headerlink" title="runMode:beforeDate:"></a>runMode:beforeDate:</h3><ul><li>相比上一种方法可以指定运行模式。对应<code>CFRunLoopRunInMode(mode,limiteDate,true)</code>方法,只执行一次，执行完就退出。</li><li>可以用<code>CFRunLoopStop(runloopRef)</code>退出runloop。在第一个input source（非timer）被处理或到达limitDate之后runloop退出。</li></ul><p>OK，关于RunLoop就总结到这，感谢各位大佬的文章让我能够搞懂这么”高端”的东西，再次献上我的膝盖orz！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a><br><a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html?spm=a2h0k.8191407.0.0&amp;from=s1.8-1-1.2" target="_blank" rel="external">sunnyxxRunLoop讲解视频</a><br><a href="https://pan.baidu.com/s/1hrMRp0C" target="_blank" rel="external">彦祖RunLoop讲解视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两篇总结了&lt;code&gt;Runtime&lt;/code&gt;的知识点，这篇就顺便来看下它的同姓兄弟&lt;code&gt;RunLoop&lt;/code&gt;吧~&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;&lt;code&gt;RunLoop&lt;/code&gt;直译过来就是一直在跑的循环。也许平时我们很少用它，但是APP的运行离不开它，当APP启动时，会启动一个主线程，并启动主线程的&lt;code&gt;RunLoop&lt;/code&gt;，&lt;code&gt;RunLoop&lt;/code&gt;会不断循环使程序一直运行，并监听用户的各种操作，然后把消息分发给线程来处理；当线程空闲时，&lt;code&gt;RunLoop&lt;/code&gt;还会让线程进入睡眠状态，达到省电的效果。这种模式被称为&lt;strong&gt;事件驱动模型&lt;/strong&gt;，伪代码如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="RunLoop" scheme="http://wonkeyz.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>Runtime学习总结（二）</title>
    <link href="http://wonkeyz.com/2017/07/15/Runtime-Learning-summary-2/"/>
    <id>http://wonkeyz.com/2017/07/15/Runtime-Learning-summary-2/</id>
    <published>2017-07-15T08:59:05.000Z</published>
    <updated>2017-11-23T07:35:09.321Z</updated>
    
    <content type="html"><![CDATA[<p>书接上回，我们来说一下<code>runtime</code>最有趣的部分，方法和消息转发机制（希望我能写的有趣😂）。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>顾名思义我们常说的方法就是<code>Method</code>，它的定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> method_t &#123;</div><div class="line">    SEL name;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">//用来存储着方法的参数类型和返回值类型</span></div><div class="line">    IMP imp;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> SortBySELAddress :</div><div class="line">        public std::binary_function&lt;<span class="keyword">const</span> method_t&amp;,</div><div class="line">                                    <span class="keyword">const</span> method_t&amp;, <span class="keyword">bool</span>&gt;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">bool</span> operator() (<span class="keyword">const</span> method_t&amp; lhs,</div><div class="line">                         <span class="keyword">const</span> method_t&amp; rhs)</div><div class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><a id="more"></a><p>来看一下几个参数：</p><h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>name</code>：方法名，类型为<code>SEL</code>，即方法选择器，是一个指向方法的指针，定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</div></pre></td></tr></table></figure></p><p>方法的<code>selector</code>用于方法表示运行时的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code>类型的地址)，这个标识就是<code>SEL</code>，也可以理解为区分方法的ID。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的<code>SEL</code>，所以Objective-C中方法命名有时会带上参数类型(如<code>[[NSNumber alloc] initWithInt:5]</code>)，这也直接导致了OC的方法名长的一批…那么为什么这么做呢？因为工程中的所有的<code>SEL</code>组成一个<code>Set</code>集合，<code>Set</code>的特点就是唯一，因此SEL是唯一的，这加快了方法的查询速度。<br><code>SEL</code>相关操作函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取方法选择器名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"></div><div class="line"><span class="comment">// 向运行时系统注册一个方法名称，将方法名映射到一个选择器，并返回这个选择器，如果该方法名称已经注册，则直接返回其对应的SEL</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"></div><div class="line"><span class="comment">// 向运行时系统注册一个方法名称，方法实现等同于sel_registerName</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"></div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure></p><h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>imp</code>：方法的实现，类型为<code>IMP</code>，是一个函数指针，定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*IMP)(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> );</div></pre></td></tr></table></figure></p><p>这个函数指针指向的函数就是我们要执行方法的实现，第一个参数是指向<code>self</code>的指针(如果是实例方法，指向类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是<code>SEL</code>，接下来是方法的参数列表。 如果我们拿到了<code>IMP</code>，就意味着得到了执行某个实例某个方法的入口，我们就可以绕开消息传递机制，直接执行方法，这在后面会提到。<br>每个方法名都对应一个<code>SEL</code>类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址，反之亦然，<code>SEL</code>与<code>IMP</code>形成映射关系。<br><code>IMP</code>相关操作函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获得方法的实现</span></div><div class="line">method_getImplementation( Method method);</div><div class="line"></div><div class="line"><span class="comment">// 设置方法的实现（该函数返回值是方法设置前的实现）</span></div><div class="line">IMP method_setImplementation( Method method, IMP imp);</div><div class="line"></div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations( Method m1, Method m2);</div></pre></td></tr></table></figure></p><h3 id="Method相关操作函数"><a href="#Method相关操作函数" class="headerlink" title="Method相关操作函数"></a>Method相关操作函数</h3><p>除了上面提到的一些，还有以下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 获取方法名</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div></pre></td></tr></table></figure></p><ul><li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li><li><code>method_getName</code>函数，返回一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li></ul><h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>我想大家项目里多多少少都会用到<code>Method Swizzling</code>，它通过<code>class_replaceMethod</code>，<code>method_exchangeImplementations</code>函数来重新映射方法对应的实现，是面向切面编程的的一种实践，它的交换原理如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IMP imp1 = method_getImplementation(m1);</div><div class="line">IMP imp2 = method_getImplementation(m2);</div><div class="line">method_setImplementation(m1, imp2);</div><div class="line">method_setImplementation(m2, imp1);</div></pre></td></tr></table></figure></p><p>这里就不放<code>Method Swizzling</code>实现代码了，大家应该都能背下来了，说几点要注意的地方：</p><ul><li><code>Method Swizzling</code>应该总在<code>+load</code>中执行：Objective-C在运行时会自动调用类的两个方法<code>+load</code>和<code>+initialize</code>。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用，这就意味着<code>+initialize</code>不一定被调用，所以在<code>+load</code>能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。</li><li><code>Method Swizzling</code>应该总是在<code>dispatch_once</code>中执行：<code>Method Swizzling</code>会改变全局状态，所以应确保无论有多少线程<code>method swizzling</code>只被执行了一次，<code>dispatch_once</code>可以做到这一点。</li><li>理清<code>Method</code>、<code>SEL</code>、<code>IMP</code>三者关系：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(<code>Method</code>)，其中key是一个特定名称，即选择器(<code>SEL</code>)，其对应一个实现(<code>IMP</code>)，即指向底层C函数的指针。为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</li><li>谨慎使用：<code>Method Swizzling</code>虽然是“黑科技”，但是这一切都发生的悄无声息，给代码的维护带来了一些麻烦，甚至会产生难以排查的bug，所以在使用<code>method swizzling</code>时要谨慎，记得交换完再调回自己，保证只交换一次，否则就会乱套。<br>如果你还想更深入的了解<code>Method Swizzling</code>，可以看下这些好文：<br><a href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/" target="_blank" rel="external">Objective-C Method Swizzling</a><br><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="external">Objective-C的hook方案（一）: Method Swizzling</a></li></ul><h2 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h2><p>重头戏来了，Objective-C中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p><h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>当执行<code>[receiver message]</code>代码时，编译器会将其转化为调用<code>objc_msgSend</code>函数，该函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p><p>这个函数通过<code>receiver</code>和<code>selector</code>找到了方法的实现，找到后调用方法的实现，并将<code>receiver</code>和<code>arg</code>传给方法实现，最后把方法实现的返回值作为函数的返回值。<br>那么它是怎么找到方法实现的呢？我们来看一下步骤：<br>1.检测这个<code>selector</code>是不是要忽略的。比如<code>Mac OS X</code>开发，有了垃圾回收就不理会<code>retain</code>,<code>release</code>这些函数了。<br>2.检测这个<code>receiver</code>是不是<code>nil</code>。给一个空对象发送消息会被忽略掉。<br>3.查找这个类的<code>IMP</code>，先从<code>cache</code>里面找，找到就跳到对应的函数去执行。<br>4.如果<code>cache</code>找不到就去类的<code>methodLists</code>里找。<br>5.如果<code>methodLists</code>找不到就用对象的<code>isa</code>到父类的<code>methodLists</code>去找，直到找到根类为止。（这一套下来还找不到就进入<strong>动态方法解析</strong>，稍后分析）<br>编译器会根据情况在<code>objc_msgSend</code>，<code>objc_msgSend_stret</code>，<code>objc_msgSendSuper</code>，或<code>objc_msgSendSuper_stret</code>四个方法中选一个调用。如果是传递给超类就会调用带Super的函数，如果返回值是数据结构而不是简单值时就会调用带stret的函数。在i386平台返回类型为浮点消息会调用<code>objc_msgSend_fpret</code>函数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出结果均为Son</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>为啥呢？执行<code>[self class]</code>编译器会先调用<code>objc_msgSend</code>去Son里找，没找到；然后调用<code>objc_msgSendSuper</code>去Father里找，一直找到<code>NSObject</code>，OK我们看下<code>-(Class)class</code>的源码，摘自<a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/NSObject.mm" target="_blank" rel="external">NSObject.mm</a>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (Class)<span class="keyword">class</span> &#123;</div><div class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>根据源码得知第一句返回Son。<br>同理在执行<code>[super class]</code>时，编译器直接调用<code>objc_msgSendSuper</code>直到找到<code>NSObject</code>，那么此时的<code>self</code>是谁呢？我们来看下<code>super</code>与<code>self</code>的区别：<br><code>self</code>是类的一个<strong>隐藏参数</strong>，每个方法的实现的第一个参数即为self。而<code>super</code>并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，跳过<code>objc_msgSend</code>直接用<code>objc_msgSendSuper</code>调用父类的方法，而不是本类中的方法。而它实际上与<code>self</code>指向都是消息接收者。为了理解这一点，我们先来看看super的定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_super &#123; <span class="keyword">id</span> receiver; Class superClass; &#125;;</div></pre></td></tr></table></figure></p><p>当我们使用<code>super</code>来接收消息时，编译器会生成一个<code>objc_super</code>结构体，参数<code>receiver</code>即消息的实际接收者，也就是上面例子的Son对象，与<code>self</code>相同；参数<code>superClass</code>即指针当前类的父类；接下来用<code>objc_msgSendSuper</code>调用父类的<code>class</code>方法，但是消息接受者仍是<code>self</code>，所以在这里<code>[self class]</code>与<code>[super class]</code>其实是等价的，结果还是Son。</p><h3 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h3><p>我们在一个方法中使用最多的参数就是<code>self</code>了，但它是怎么被获取到的呢？其实它是<code>objc_msgSend</code>函数的隐藏参数之一，代表消息的接收对象，还有一个不常用的是<code>_cmd</code>，它是方法选择器，一般在关联对象时作为key使用。</p><h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>前面我们提到拿到了方法的<code>IMP</code>，就可以可以避开消息绑定而直接获取方法的地址并调用方法。这种做法一般不常用，但当我们在循环内多次调用某个方法时，通过获取方法<code>IMP</code>直接调用会高效得多。那么怎么获取呢？<code>NSObject</code>类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码，如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"> </div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target</div><div class="line">    methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> ( i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++ )</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>想必大家都遇到过<code>unrecognized selector sent to instance...</code>这类crash，原因是调用了一个该对象无法接收的消息，即未声明的方法。为了避免这种crash的发生，我们通常会使用<code>respondsToSelector:</code>来判断一下是否响应再去调用，下面我们来讨论另一种方式：<strong>消息转发(message forwarding)</strong>机制，它主要分三个步骤：</p><h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>当对象在接收到未知消息时，会先去类里找<code>+resolveInstanceMethod:</code>(实例方法)或<code>+resolveClassMethod:</code>(类方法)，如果你重写了他们，那么对象就会调用它们通过<code>class_addMethod</code>函数动态添加该未知方法到类里，具体重写代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</div><div class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(classMethod:)) &#123;</div><div class="line">        class_addMethod(object_getClass(<span class="keyword">self</span>), sel, class_getMethodImplementation(object_getClass(<span class="keyword">self</span>), <span class="keyword">@selector</span>(myClassMethod:)), <span class="string">"v@:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [class_getSuperclass(<span class="keyword">self</span>) resolveClassMethod:sel];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(instanceMethod:)) &#123;</div><div class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, class_getMethodImplementation([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(myInstanceMethod:)), <span class="string">"v@:"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这一特性一般用于实现动态属性<a href="http://blog.csdn.net/daydreamingboy/article/details/22682851" target="_blank" rel="external">@dynamic</a>。</p><h4 id="重定向接收者"><a href="#重定向接收者" class="headerlink" title="重定向接收者"></a>重定向接收者</h4><p>如果上一步返回<code>NO</code>，<code>Runtime</code>会再给我们一次弥补的机会，我们可以通过重写<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>或<code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>来重定向实例方法或类方法的消息接收者，将“锅”甩给方法返回的对象，示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Doctor</span> : <span class="title">NSObject</span>  </span></div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)operate;  </div><div class="line"></div><div class="line"><span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Doctor</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)operate &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Teacher</span> : <span class="title">NSObject</span>  </span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Teacher</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operate)];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector  </div><div class="line">&#123;  </div><div class="line">    Doctor *doctor = [[Doctor alloc]init];  </div><div class="line">    <span class="keyword">if</span> ([doctor respondsToSelector:aSelector]) &#123;  </div><div class="line">        <span class="keyword">return</span> doctor;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p><h4 id="真正的消息转发"><a href="#真正的消息转发" class="headerlink" title="真正的消息转发"></a>真正的消息转发</h4><p>如果上面方法返回<code>nil</code>或<code>self</code>，那么我们的最后一根救命稻草就是重写<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code>和<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code>方法，触发真正的消息转发：<br>1.<code>Runtime</code>系统先向对象发送<code>methodSignatureForSelector</code>消息，并取到返回的方法签名；<br>2.通过方法签名生成<code>forwardInvocation:</code>的<code>anInvocation</code>(<a href="http://www.jianshu.com/p/03e7279a9916" target="_blank" rel="external">NSInvocation</a>)对象，该对象包含了未发送消息的<code>selector</code>,<code>target</code>和参数，通过该对象对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，避免抛出异常。<br>具体实现如下:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];  </div><div class="line">    <span class="keyword">if</span> (signature==<span class="literal">nil</span>) &#123;  </div><div class="line">        signature = [someObj methodSignatureForSelector:aSelector];  </div><div class="line">    &#125; </div><div class="line">      </div><div class="line">    <span class="keyword">return</span> signature;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation  </div><div class="line">&#123;  </div><div class="line">    SEL seletor = [anInvocation selector];  </div><div class="line">    <span class="keyword">if</span> ([someObj respondsToSelector:seletor]) &#123;  </div><div class="line">        [anInvocation invokeWithTarget:someObj];  </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>NSObject</code>的<code>forwardInvocation:</code>方法只是简单调用了<code>doesNotRecognizeSelector:</code>方法抛出上面提到的异常，它不会转发任何消息。<br><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象，或者它也可以象一个运输站将所有的消息都发送给同一个接收对象，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。<br>上述三个步骤组成了完整的消息转发机制，我整理了一张图简单描述整个过程：<br><img src="http://owgqmweju.bkt.clouddn.com/17-11-23/17288307.jpg" alt=""><br>回过头看2、3部，它们让一个对象能够处理其他对象的消息，但表面上看仍是该对象在处理这个消息，而这正是<strong>多继承</strong>的特性。消息转发弥补了Objective-C无法多继承的软肋，也避免了因为多继承导致单个类变得臃肿的缺点。如果你对消息转发机制的原理感兴趣可以看下<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/#总结" target="_blank" rel="external">Objective-C 消息发送与转发机制原理</a></p><h2 id="Category与Protocol"><a href="#Category与Protocol" class="headerlink" title="Category与Protocol"></a>Category与Protocol</h2><p>最后我们来聊聊平时比较常用的<code>Category</code>与<code>Protocol</code>，研究下他们在<code>runtime</code>是怎样实现和使用的。</p><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p><code>Category</code>的存在使我们可以动态地为已知类添加方法，项目里随处可见各种类的分类应用，我们来看下它在<code>runtime</code>里的数据结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Category表示一个指向objc_category结构体的指针</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">    <span class="keyword">char</span> *category_name                          OBJC2_UNAVAILABLE;<span class="comment">// 分类名</span></div><div class="line">    <span class="keyword">char</span> *class_name                             OBJC2_UNAVAILABLE;<span class="comment">// 分类所属的类名</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods    OBJC2_UNAVAILABLE;<span class="comment">// 实例方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *class_methods       OBJC2_UNAVAILABLE;<span class="comment">// 类方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols         OBJC2_UNAVAILABLE;<span class="comment">// 分类所实现的协议列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>编译器会把分类的<code>instance_methods</code>里的方法添加到类的<code>methodLists</code>里，把<code>class_methods</code>里的方法添加到类的元类的<code>methodLists</code>里。我们来看个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line"> + (<span class="keyword">void</span>)foo;</div><div class="line"> - (<span class="keyword">void</span>)foo;</div><div class="line"> <span class="keyword">@end</span></div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Sark</span>)</span></div><div class="line"> - (<span class="keyword">void</span>)foo</div><div class="line"> &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"IMP: -[NSObject(Sark) foo]"</span>);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="keyword">@end</span></div><div class="line"></div><div class="line"> <span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">  <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">      [<span class="built_in">NSObject</span> foo];</div><div class="line">      [[<span class="built_in">NSObject</span> new] foo];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//程序正常运行，输出结果均为IMP: -[NSObject(Sark) foo]</span></div></pre></td></tr></table></figure></p><p>分析：分类声明的类方法被添加到元类的方法列表中，所以在调用<code>[NSObject foo]</code>时，编译器先去元类中查找<code>foo</code>的<code>IMP</code>，没找到，再去元类的父类里找，所以又回到了<code>NSObject</code>，找到了foo，调用。而实例方法被添加到了类的方法列表中，所以在调用<code>[[NSObject new] foo]</code>时，去<code>NSObject</code>里找<code>foo</code>，直接调用。<br>关于<code>Category</code>更详细的介绍可以看下<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a>，<br>这里再安利一个方便的分类库<a href="https://github.com/ibireme/YYCategories" target="_blank" rel="external">YYCategories</a>。</p><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><p>通过Protocol的定义，我们可以看出它是一个对象类型的结构体：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</div></pre></td></tr></table></figure></p><p>相关操作函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定的协议，如果该协议只是声明而未实现过则返回nil</span></div><div class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></div><div class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 创建新的协议实例，如果已有同名协议存在则返回nil</span></div><div class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 在运行时中注册新创建的协议</span></div><div class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</div><div class="line"></div><div class="line"><span class="comment">// 为协议添加方法</span></div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"></div><div class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></div><div class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class="line"></div><div class="line"><span class="comment">// 为协议添加属性</span></div><div class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"></div><div class="line"><span class="comment">// 返回协议名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</div><div class="line"></div><div class="line"><span class="comment">// 测试两个协议是否相等</span></div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class="line"></div><div class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></div><div class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"></div><div class="line"><span class="comment">// 获取协议中的属性列表</span></div><div class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 获取协议的指定属性</span></div><div class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"></div><div class="line"><span class="comment">// 获取协议采用的协议</span></div><div class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure></p><p>当我们使用<code>objc_allocateProtocol</code>动态添加一个协议后，再使用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和<code>protocol_addProperty</code>往协议中添加方法或属性，最后记得调用<code>objc_registerProtocol</code>注册这个协议，注册后不能修改该协议。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p><code>Runtime</code>还有一些关于<code>block</code>的操作函数，如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></div><div class="line"><span class="comment">// block参数必须是method_return_type ^(id self, args...)形式的</span></div><div class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</div><div class="line"></div><div class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></div><div class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</div><div class="line"></div><div class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></div><div class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</div></pre></td></tr></table></figure></p><h3 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h3><p>关于弱引用的操作函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></div><div class="line"><span class="keyword">id</span> objc_loadWeak ( <span class="keyword">id</span> *location );</div><div class="line"></div><div class="line"><span class="comment">// 存储__weak变量的新值</span></div><div class="line"><span class="keyword">id</span> objc_storeWeak ( <span class="keyword">id</span> *location, <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure></p><p>这里不做详细介绍，感兴趣可以看下<a href="https://halfrost.com/ios_block_retain_circle/" target="_blank" rel="external">深入研究 Block 用 weakSelf、strongSelf</a>。  </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我这阵子学习<code>runtime</code>的所有总结，都是一些基础知识，不算深入，但比起之前的小白程度进步了不少。作为一名程序猿，不应该只停留在会用的程度，要有一言不合就看源码的态度！<br>还要感谢各位大佬的博文分享（文中有链接），如果你觉得文章哪里有问题，欢迎指正~如果你觉得这篇文章太肤浅，推荐<a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="external">霜神的runtime入院系列</a>，反正我是跪着看完的orz。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接上回，我们来说一下&lt;code&gt;runtime&lt;/code&gt;最有趣的部分，方法和消息转发机制（希望我能写的有趣😂）。&lt;/p&gt;
&lt;h2 id=&quot;Method&quot;&gt;&lt;a href=&quot;#Method&quot; class=&quot;headerlink&quot; title=&quot;Method&quot;&gt;&lt;/a&gt;Method&lt;/h2&gt;&lt;p&gt;顾名思义我们常说的方法就是&lt;code&gt;Method&lt;/code&gt;，它的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; method_t *Method;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; method_t &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SEL name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *types;  &lt;span class=&quot;comment&quot;&gt;//用来存储着方法的参数类型和返回值类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    IMP imp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; SortBySELAddress :&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        public std::binary_function&amp;lt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; method_t&amp;amp;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; method_t&amp;amp;, &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; operator() (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; method_t&amp;amp; lhs,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                         &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; method_t&amp;amp; rhs)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; lhs.name &amp;lt; rhs.name; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="runtime" scheme="http://wonkeyz.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Runtime学习总结（一）</title>
    <link href="http://wonkeyz.com/2017/07/09/Runtime-Learning-summary-1/"/>
    <id>http://wonkeyz.com/2017/07/09/Runtime-Learning-summary-1/</id>
    <published>2017-07-09T03:00:35.000Z</published>
    <updated>2018-02-01T01:34:52.432Z</updated>
    
    <content type="html"><![CDATA[<p><code>Runtime</code>在业内有iOS开发‘‘黑科技’’之称，但在平时开发中也就接触了<code>Method Swizzling</code>，<code>AssociatedObject</code>这几种应用，用了这么久OC，却对它的内在一无所知，实在说不过去…今天我来总结一下最近学习<code>runtime</code>的知识点，看看它究竟‘‘黑’’在哪里。<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们都知道Objective-C是一门动态语言，可以在程序运行时创建，检查，修改类、对象和它们的方法，这一切都归功于<code>runtime</code>，它是用C和汇编写的库，这个库使C具有了面向对象的能力。总结起来，<code>Runtime</code>库主要做了几件事:</p><ul><li>封装：用C的结构体表示OC的对象，用C的函数实现OC的方法，这些结构体和函数被<code>runtime</code>函数封装后，OC就具有了动态的特性。</li><li>收发消息：在对象执行某个方法时，这个方法被<code>runtime</code>当做一条消息发送给接收者，也就是对象，<code>Runtime</code>会根据接收者能否响应该消息而做出不同的反应。  </li></ul><p>下面我们逐一来看下平时再熟悉不过的类与对象、成员变量与属性的数据结构和操作函数。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>通过<code>objc.h</code>与<code>runtime.h</code>我们可以看到<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里定义了一个指向objc_class结构体的指针Class，也就是OC中的类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"><span class="comment">// 结构体定义如下</span></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">    </div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                   OBJC2_UNAVAILABLE;<span class="comment">// 父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                      OBJC2_UNAVAILABLE;<span class="comment">// 类名</span></div><div class="line">    <span class="keyword">long</span> version                          OBJC2_UNAVAILABLE;<span class="comment">// 类版本，默认为0</span></div><div class="line">    <span class="keyword">long</span> info                            OBJC2_UNAVAILABLE;<span class="comment">// 类信息，供运行时使用的一些位标识</span></div><div class="line">    <span class="keyword">long</span> instance_size                   OBJC2_UNAVAILABLE;<span class="comment">// 实例变量大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars         OBJC2_UNAVAILABLE;<span class="comment">// 成员变量列表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists OBJC2_UNAVAILABLE;<span class="comment">// 方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache              OBJC2_UNAVAILABLE;<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UNAVAILABLE;<span class="comment">// 协议列表</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p><p>我们先来看下这几个字段：</p><ul><li><code>isa</code>：我们知道OC中对象的<code>isa</code>指向类，同样类也有一个<code>isa</code>指针，它指向<code>meta Class</code>(元类)，这里类也是一个对象。</li><li><code>super_class</code>：指向该类的父类，如果该类已经是<code>Root Class</code>(如<code>NSObject</code>或<code>NSProxy</code>)，则<code>super_class</code>为<code>NULL</code>。</li><li><p><code>cache</code>：该字段用于缓存调用过的方法。<code>cache</code>指针指向<code>objc_cache</code>结构体，这个结构体的定义如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE; <span class="comment">// 指定分配缓存bucket的总数。runtime使用这个字段确定线性查找数组的索引位置</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied OBJC2_UNAVAILABLE; <span class="comment">// 实际占用缓存bucket总数</span></div><div class="line">    Method buckets[<span class="number">1</span>] OBJC2_UNAVAILABLE; <span class="comment">// 指向Method数据结构指针的数组，这个数组的元素总数不能超过mask+1，如果为空则表示缓存bucket没有被占用，它有可能是不连续的，会随着时间而变大。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></li><li><p>当我们调用一个方法时，这个方法就会被放到<code>cache</code>中，下次调用<code>runtime</code>就会优先去<code>cache</code>中查找，这样就避免了每次都直接去<code>methodLists</code>中查找，提高了效率。</p></li></ul><h4 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h4><p>看完了<code>Class</code>我们再来看一下对象，参考<code>objc-private.h</code>部分源码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line"></div><div class="line">public:</div><div class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></div><div class="line">    Class ISA();</div><div class="line"></div><div class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></div><div class="line">    Class getIsa();</div><div class="line"></div><div class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></div><div class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></div><div class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></div><div class="line">    <span class="comment">// initClassIsa(): class objects</span></div><div class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></div><div class="line">    <span class="comment">// initIsa(): other objects</span></div><div class="line">    <span class="keyword">void</span> initIsa(Class cls <span class="comment">/*nonpointer=false*/</span>);</div><div class="line">    <span class="keyword">void</span> initClassIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</div><div class="line">    <span class="keyword">void</span> initProtocolIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</div><div class="line">    <span class="keyword">void</span> initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor);</div><div class="line">    <span class="comment">// 省略其他方法声明...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure></p><p><code>objc_object</code>结构体包含一个类型为<code>isa_t</code>的<code>isa</code>指针，这个指针就是我们所说的指向这个对象所属类的指针。publich里面定义了一些操作<code>isa</code>的方法。<code>Runtime</code>库会在该类的方法列表及父类的方法列表中去寻找与消息对应的<code>selector</code>，找到后即执行这个方法。<br>下面的<code>id</code>是一个<code>objc_object</code>结构体类型的指针，这个类型的对象能够转换成任意类型的对象，类似于C语言中void *指针的作用。<br>这里有一点要特殊说明，其实<code>isa</code>并不总是指向实例对象所属的类，在我们使用KVO时，会产生一个中间类，系统会通过<code>isa-swizzling</code>把<code>isa</code>指向这个类而不是真实的类，所以不能依靠它来确定类型，而应该用<code>class</code>方法来确定实例对象的类。详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a>。</p><h4 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta Class"></a>Meta Class</h4><p>上面我们说到类本身也是对象，那么他的<code>isa</code>指向谁呢？答案就是元类<code>Meta Class</code>。当我们向一个对象发送消息时，<code>runtime</code>会在这个对象所属类的方法列表中查找方法，而向一个类发送消息时，会在这个类的<code>Meta Class</code>的方法列表中查找。<br><code>Meta Class</code>存储着一个类的所有类方法，每个类都会有一个单独的<code>Meta Class</code>，因为每个类的类方法基本不可能完全相同。<br>那么问题来了，<code>Meta Class</code>的<code>isa</code>又指向谁呢？这么搞下去岂不是无穷无尽…为了避免这种尴尬的问题，Objective-C的设计者让所有<code>Meta Class</code>的<code>isa</code>都指向基类（Root Class）的<code>Meta Class</code>，即所有的类的<code>Meta Class</code>，包括Root Class，Superclass，Subclass的<code>isa</code>都指向Root class的<code>Meta Class</code>，而Root Class的<code>Meta Class</code>的<code>isa</code>指针又指向了它自己，这样就形成一个闭环。如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-11-17/86473124.jpg" alt="图1"><br>再来一个小demo来验证一下上图（取自<a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="external">神经病院objc runtime入院考试</a>）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 结果为1 0 0 0</span></div></pre></td></tr></table></figure></p><p>先来看下<code>isKindOfClass:</code>,<code>isMemberOfClass:</code>在<code>Object.mm</code>中的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass &#123;</div><div class="line">     Class cls;</div><div class="line">     <span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass)</div><div class="line">          <span class="keyword">if</span> (cls == (Class)aClass)</div><div class="line">               <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass &#123;</div><div class="line">     <span class="keyword">return</span> isa == (Class)aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们从头走一遍，res1第一次cls是NSObject的Meta Class，因为他是基类，所有第二次cls又指回了NSObject，返回YES；res2只走了一次返回NO；res3第一次cls是Sark的Meta Class，第二次cls是NSObject的Meta Class，第三次cls是NSObject，返回NO；res4显然返回NO。</p><h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="类操作函数"><a href="#类操作函数" class="headerlink" title="类操作函数"></a>类操作函数</h4><p>聊完类与对象的基本结构，我们来看下都可以对它们做哪些操作。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"><span class="comment">// 获取元类</span></div><div class="line">Class objc_getMetaClass( Class cls );</div><div class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div><div class="line"></div><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 成员变量操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types ); </div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 属性操作函数</span></div><div class="line"><span class="comment">// 获取指定的属性</span></div><div class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取属性列表</span></div><div class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 添加属性</span></div><div class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"><span class="comment">// 替换类的属性</span></div><div class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"></div><div class="line"><span class="comment">// 协议操作函数</span></div><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p><p><code>Objective-C</code>不支持往已存在的类中添加成员，因此不管是系统库提供的类，还是我们自定义的类，都无法动态添加成员变量。所以<code>class_addIvar</code>只支持给运行时创建的非元类添加成员变量，还需要注意这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。<br>类似于<code>class_copyIvarList</code>,<code>class_getClassVariable</code>的函数返回的数组在使用后需要使用<code>free()</code>手动释放，<code>outCount</code>指针返回数组的大小。<br><code>class_conformsToProtocol</code>相当于<code>conformsToProtocol:</code>方法。  </p><h4 id="对象操作函数"><a href="#对象操作函数" class="headerlink" title="对象操作函数"></a>对象操作函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div><div class="line"></div><div class="line"><span class="comment">// 修改对象实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 修改对象实例变量的值，如果Ivar已知，则调用该函数会比object_setInstanceVariable快，下面一样</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"></div><div class="line"><span class="comment">// 返回对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure><p>举一个简单的例子，在运行时转换对象的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p><h4 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h4><h5 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes ); <span class="comment">// 如果创建的是root class，则superclass为Nil。extraBytes通常为0</span></div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls ); <span class="comment">// 如果程序中还存在该类或子类的实例，就不能够调用该方法。</span></div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls ); <span class="comment">// 创建了新类后，使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类。</span></div></pre></td></tr></table></figure><p>代码示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line"></div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line"></div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line"></div><div class="line">objc_registerClassPair(cls);</div><div class="line"></div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div><div class="line"></div><div class="line"><span class="comment">// 输出结果均为run sub method 1</span></div></pre></td></tr></table></figure></p><h5 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj ); <span class="comment">// 不会释放移除任何与该实例相关的引用</span></div></pre></td></tr></table></figure><p><code>class_createInstance</code>：创建实例时，会在默认的内存区域为类分配内存，无法在ARC环境下使用。这里延伸一个知识点<a href="http://www.jianshu.com/p/bab5e34e5ff0" target="_blank" rel="external">深入理解alloc、init方法</a>，<code>class_createInstance</code>效果与<code>alloc</code>方法类似，我们来对比一下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"> </div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 输出结果为NSString,__NSCFConstantString</span></div></pre></td></tr></table></figure></p><p>在使用<code>objc_destructInstance</code>函数时并不会释放并移除任何与对象相关的引用。</p><h4 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure><h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>表示实例变量的类型，指向<code>objc_ivar</code>结构体的指针，<code>ivar</code>指针地址是根据<code>class</code>结构体的地址加上基地址偏移字节得到的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name               OBJC2_UNAVAILABLE;<span class="comment">// 变量名</span></div><div class="line">    <span class="keyword">char</span> *ivar_type             OBJC2_UNAVAILABLE;<span class="comment">// 变量类型</span></div><div class="line">    <span class="keyword">int</span> ivar_offset            OBJC2_UNAVAILABLE;<span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                 OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="objc-property-t、objc-property-attribute-t"><a href="#objc-property-t、objc-property-attribute-t" class="headerlink" title="objc_property_t、objc_property_attribute_t"></a>objc_property_t、objc_property_attribute_t</h4><p><code>objc_property_t</code>：声明的属性的类型，是一个指向<code>objc_property</code>结构体的指针：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure></p><p><code>objc_property_attribute_t</code>：定义了属性的特性的结构体：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 属性特性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 属性特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p><p>列举一些常用的attribure：</p><table><thead><tr><th>attribure</th><th>name</th><th>value</th></tr></thead><tbody><tr><td>nonatomic</td><td>N</td><td>空</td></tr><tr><td>strong/retain</td><td>&amp;</td><td>空</td></tr><tr><td>weak</td><td>W</td><td>空</td></tr><tr><td>copy</td><td>C</td><td>空</td></tr><tr><td>属性的类型type</td><td>T</td><td>@”TypeName”, 如 @”NSString”</td></tr><tr><td>属性对应的实例变量Ivar</td><td>V</td><td>Ivar_name, 如 _name</td></tr><tr><td>readonly</td><td>R</td><td>空</td></tr><tr><td>getter</td><td>G</td><td>GetterName, 如 isHighlight</td></tr><tr><td>setter</td><td>S</td><td>SetterName, 如 setName</td></tr><tr><td>assign/atomic</td><td>默认即为assign和atomic</td><td>空</td></tr></tbody></table><h3 id="操作函数-1"><a href="#操作函数-1" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure><p>关于类型编码，感兴趣的可以看下官方文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>、<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a>。</p><h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><p>如果在开发中你准备给系统的类额外添加一个属性，你可能会想到使用继承来实现，但是只增加一个属性，就去继承一个类，未免太麻烦了。这个时候，runtime提供了一个解决方案：即关联对象(Associated Object)。函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div></pre></td></tr></table></figure></p><p>其中参数含义为：<br>1.<code>id object</code>给谁添加关联对象。<br>2.<code>const void *key</code>关联对象唯一的key，获取时会用到。<br>3.<code>id value</code>关联对象。<br>4.<code>objc_AssociationPolicy</code>关联策略，有以下几种策略：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, </div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>根据要关联对象的类型来选择关联策略。有了上面三个函数，我们就可以给分类添加/移除关联对象了，简单代码实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加关联对象（可以用方法地址作为key）</span></div><div class="line">- (<span class="keyword">void</span>)addAssociatedObject:(<span class="keyword">id</span>)object&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取关联对象（_cmd代表当前调用方法的地址）</span></div><div class="line">- (<span class="keyword">id</span>)getAssociatedObject&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure><p>实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">objc_property_t * properties = class_copyPropertyList([Model <span class="keyword">class</span>], &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">    objc_property_t property = properties[i];</div><div class="line">    <span class="comment">//属性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name = property_getName(property);</div><div class="line">    <span class="comment">//属性描述</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * propertyAttr = property_getAttributes(property);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"属性 %s 的描述为 %s"</span>, name, propertyAttr);</div><div class="line"></div><div class="line">    <span class="comment">//属性的特性</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attrCount = <span class="number">0</span>;</div><div class="line">    objc_property_attribute_t * attrs = property_copyAttributeList(property, &amp;attrCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; attrCount; j ++) &#123;</div><div class="line">        objc_property_attribute_t attr = attrs[j];</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * name = attr.name;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * value = attr.value;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"属性特性名称：%s 值：%s"</span>, name, value);</div><div class="line">    &#125;</div><div class="line">    free(attrs);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</div><div class="line">&#125;</div><div class="line">free(properties);</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以结合上表理解</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性 str 的描述为 T<span class="string">@"NSString"</span>,C,N,V_str</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：T 值：<span class="string">@"NSString"</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：C 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：N 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：V 值：_str</div><div class="line"></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性 array 的描述为 T<span class="string">@"NSArray"</span>,R,N,V_array</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：T 值：<span class="string">@"NSArray"</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：R 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：N 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：V 值：_array</div></pre></td></tr></table></figure></p><p>通过上面的简单总结，我对Objective-C类与对象的底层实现有了更深的理解，同时也感受到了<code>runtime</code>的强大。下篇文章我会总结一下方法、消息的结构与操作函数，敬请期待~</p><p>参考链接：<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime官方文档</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">Objective-C Runtime Programming Guide</a><br><a href="http://southpeak.github.io/categories/objectivec/" target="_blank" rel="external">南大runtime总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;在业内有iOS开发‘‘黑科技’’之称，但在平时开发中也就接触了&lt;code&gt;Method Swizzling&lt;/code&gt;，&lt;code&gt;AssociatedObject&lt;/code&gt;这几种应用，用了这么久OC，却对它的内在一无所知，实在说不过去…今天我来总结一下最近学习&lt;code&gt;runtime&lt;/code&gt;的知识点，看看它究竟‘‘黑’’在哪里。&lt;br&gt;
    
    </summary>
    
    
      <category term="runtime" scheme="http://wonkeyz.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化UI篇（二）</title>
    <link href="http://wonkeyz.com/2017/06/29/iOS-Performance%20optimization-UI-2/"/>
    <id>http://wonkeyz.com/2017/06/29/iOS-Performance optimization-UI-2/</id>
    <published>2017-06-29T08:59:23.000Z</published>
    <updated>2017-10-27T10:36:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>书接上回，我们来聊一下UI性能优化的几大重点对象。</p><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>我相信每一位iOS开发人员写<code>UITableView</code>肯定都要写吐了，但是大家确定在写的时候都注意到这些原则or细节了吗？</p><ul><li>尽量避免动态高度的cell，如果已确定控件的高度，直接使用<code>tableView</code>的<code>rowHeight</code>、<code>sectionHeaderHeight</code>和<code>sectionFooterHeight</code>设置高度，避免请求delegate。在<code>heightForRowAtIndexPath:</code>中尽量不使用<code>cellForRowAtIndexPath:</code>，如果你需要用到它，最好只用一次然后缓存结果。<a id="more"></a></li><li>使用<code>dequeueReusableCellWithIdentifier:</code>或<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>复用cell，后者需要搭配<code>registerClass/Nib:forCellReuseIdentifier:</code>使用，该方法会在默认没有cell可复用的时候自动创建一个新的cell出来，推荐使用后者。</li><li>对于动态高度的cell，做对应标记，缓存行高。推荐使用sunnyxx大神的<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView-FDTemplateLayoutCell</a>。如果cell对应的模型没有发生变化，则不做相应的计算渲染处理。</li><li>使用自定义视图构造的cell，要避免调用<code>layoutIfNeeded</code>每次对其进行布局。尽量固定cell子视图的尺寸，确保每个cell渲染所需时间最小化。<br>尽量使用不透明的子视图，包括cell本身，这点已经在上篇基本法中提过。<br>确保cell的子视图数量最少，避免耗费性能的操作，如图片的缩放、渐变等。<br>如果自定义cell的样式基本确定不会发生大的布局变化，或者在滑动时有明显的性能问题，那么你可能需要异步绘制这个cell，我会在自定义视图部分讲解。</li><li>在快速滚动时如果出现了卡顿，那么你除了使用异步绘制cell，还可以考虑使用‘‘占位’’cell，这种方式在国内的App比较少见，如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-26/41893848.jpg" alt="图1"><br>‘‘占位’’cell类似于占位图，它告诉用户这部分即将展示一些信息，当滚动速度降低到一定值时，再展示最终数据。部分代码实现如下：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</div><div class="line">    <span class="comment">// 通过scrollView的panGestureRecognizer获取滑动速率</span></div><div class="line">    <span class="keyword">self</span>.velocity = [scrollView.panGestureRecognizer velocityInView:<span class="keyword">self</span>.view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="comment">// 根据滑动速率做相应内容展示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.velocity.y &gt; maxVelocity) &#123;</div><div class="line">        <span class="keyword">return</span> placeholderCell;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>还有一种sao套路是按需加载cell<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    <span class="keyword">if</span> (labs(cip.row - ip.row) &gt; skipCount) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            <span class="keyword">if</span> (indexPath.row + <span class="number">3</span> &lt; datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="keyword">if</span> (indexPath.row &gt; <span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在`tableView:cellForRowAtIndexPath:`方法中加入判断：，修改样式</span></div><div class="line"><span class="keyword">if</span> (needLoadArr.count &gt; <span class="number">0</span></div><div class="line">    &amp;&amp;</div><div class="line">    [needLoadArr indexOfObject:indexPath] == <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>详见<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="external">VVeboTableViewDemo</a></p><h3 id="UIWebView、WKWebView"><a href="#UIWebView、WKWebView" class="headerlink" title="UIWebView、WKWebView"></a>UIWebView、WKWebView</h3><p>由于H5具有动态化，不用发版等优势，越来越多的H5页面出现的原生App中。苹果提供了两种加载H5的控件，<code>UIWebView</code>,<code>WKWebView</code>，<code>WKWebView</code>是iOS8的新特性，通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度更快，占用内存更小，下面列举一些其它的优势：</p><ul><li>支持更多的H5特性</li><li>60fps的滚动刷新率及内置手势</li><li>与Safari相同的JavaScript引擎</li><li>将<code>UIWebView</code>和<code>UIWebViewDelegate</code>重构成了14个类，3个协议，可以让开发者进行更细致的配置</li></ul><p>简直完爆<code>UIWebView</code>，所以想要优化你的webView，那么从现在开始弃<code>UIWebView</code>，用<code>WKWebView</code>吧！下面简单介绍一下<code>WKWebView</code>。  </p><h4 id="加载页面"><a href="#加载页面" class="headerlink" title="加载页面"></a>加载页面</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import<span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loadRequest &#123;</div><div class="line">    _wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds configuration:[<span class="built_in">WKWebViewConfiguration</span> new]]; </div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.wonkeyz.com/"</span>]];</div><div class="line">    [_wkWebView loadRequest:request];</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="原生调用JS"><a href="#原生调用JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h4><p>1.使用<code>WKUserScript</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JS代码</span></div><div class="line"><span class="built_in">NSString</span> *js = <span class="string">@"window.alert('测试原生调用JS');"</span>;</div><div class="line"><span class="comment">// 根据JS代码初始化WKUserScript对象</span></div><div class="line"><span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:js injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentEnd</span> forMainFrameOnly:<span class="literal">YES</span>];</div><div class="line"><span class="comment">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</span></div><div class="line"><span class="built_in">WKWebViewConfiguration</span> *config = [<span class="built_in">WKWebViewConfiguration</span> new];</div><div class="line">[config.userContentController addUserScript:script];</div></pre></td></tr></table></figure></p><p>2.直接调用JS代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[_wkWebView evaluateJavaScript:js completionHandler:^(<span class="keyword">id</span> _Nullable, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        <span class="comment">// 获取js方法返回值，回调操作等</span></div><div class="line">    &#125;];</div></pre></td></tr></table></figure></p><h4 id="JS调用原生"><a href="#JS调用原生" class="headerlink" title="JS调用原生"></a>JS调用原生</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向JS注入OC方法</span></div><div class="line">[[_webView configuration].userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"ocMethod"</span>];</div><div class="line"></div><div class="line"><span class="comment">// JS调用</span></div><div class="line">window.webkit.messageHandlers.ocMethod.postMessage(value);</div><div class="line"></div><div class="line"><span class="comment">// 接收JS调用</span></div><div class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JS 调用了 %@ 方法，传回参数 %@"</span>,message.name,message.body);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>就是这么简单！不过<code>WKWebView</code>还是有一些坑的，有很多相关文章，这里奉上几篇大佬的总结<a href="http://www.jianshu.com/p/403853b63537" target="_blank" rel="external">WKWebView的使用和各种坑的解决方法（OC＋Swift）</a>，<a href="http://www.jianshu.com/p/7bb5f15f1daa" target="_blank" rel="external">WKWebView学习笔记</a>。</p><h3 id="自定义视图的绘制"><a href="#自定义视图的绘制" class="headerlink" title="自定义视图的绘制"></a>自定义视图的绘制</h3><p>我们来做一个简单的demo，如图：<img src="http://owgqmweju.bkt.clouddn.com/17-10-27/22309726.jpg" alt="图2"><br>正常代码布局就不写了，这里给出绘制代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"drink.jpg"</span>];</div><div class="line">        <span class="built_in">CGRect</span> imageFrame = <span class="built_in">CGRectMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">80</span>, <span class="number">80</span>);</div><div class="line">        [image drawInRect:imageFrame];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *title = <span class="string">@"This is title,This is title,This is title,This is title"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *titleFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : titleFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> titleFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">10</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">30</span>);</div><div class="line">        [title drawInRect:titleFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *content = <span class="string">@"This is content,This is content,This is content,This is content,This is content"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *contentFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">13</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : contentFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kLigthTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> contentFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">40</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">40</span>);</div><div class="line">        [content drawInRect:contentFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *time = <span class="string">@"This is time"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *timeFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">12</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : timeFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kLigthTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> timeFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">80</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">20</span>);</div><div class="line">        [time drawInRect:timeFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, kLineBackColor.CGColor);</div><div class="line">        <span class="built_in">CGContextStrokeRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.height - kLineHeight, <span class="keyword">self</span>.width, kLineHeight));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>对比一下渲染时间，左为复合视图方式，右为直接绘制<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-27/34929283.jpg" alt="图3"><br>通过对比发现绘制得到的cell渲染时间缩短明显，对于更复杂的界面性能优势可想而知。因此，从性能角度来看，直接绘制视图是个不错的选择，但从维护角度来看，代码会比较难维护迭代，所以在某些界面样式稳定下来，你可以考虑重构成绘制视图。或者直接使用上文提到的高性能框架<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYkit</a>、<a href="https://github.com/TextureGroup/Texture" target="_blank" rel="external">Texture</a>。</p><h3 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h3><p>再补充一下比较具有争议性的Auto Layout，它给我们日常开发带来了很大的便利，但便利的代价就是耗费更多的性能。<br>Auto Layout使用Cassowary算法作为约束求解工具包，他的复杂度为O（N），其中N是约束的数目，而不是元素的数目。这意味着，在一般情况下，为了确定视图中所有元素的位置和大小，可能有大概4N个方程要求解，而且方程花费的时间与元素的个数和包含的约束个数是不成比例的。当视图数量增加至几百个，直接设设置结构大小要比用自动布局快1000倍左右！(测试demo<a href="https://github.com/floriankugler/AutoLayoutProfiling" target="_blank" rel="external">AutoLayoutProfiling</a>)<br>更详细的分析请见<a href="https://draveness.me/layout-performance" target="_blank" rel="external">从 Auto Layout 的布局算法谈性能</a>。<br>所以当你为某个使用Auto Layout的界面性能消耗苦恼时，那么请改为代码布局吧😂  </p><p>UI篇的性能优化就总结到这，菜鸟第一次写这类文章还请各位大佬多包涵，只求别辣到各位大佬的双眼😂</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书接上回，我们来聊一下UI性能优化的几大重点对象。&lt;/p&gt;
&lt;h3 id=&quot;UITableView&quot;&gt;&lt;a href=&quot;#UITableView&quot; class=&quot;headerlink&quot; title=&quot;UITableView&quot;&gt;&lt;/a&gt;UITableView&lt;/h3&gt;&lt;p&gt;我相信每一位iOS开发人员写&lt;code&gt;UITableView&lt;/code&gt;肯定都要写吐了，但是大家确定在写的时候都注意到这些原则or细节了吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量避免动态高度的cell，如果已确定控件的高度，直接使用&lt;code&gt;tableView&lt;/code&gt;的&lt;code&gt;rowHeight&lt;/code&gt;、&lt;code&gt;sectionHeaderHeight&lt;/code&gt;和&lt;code&gt;sectionFooterHeight&lt;/code&gt;设置高度，避免请求delegate。在&lt;code&gt;heightForRowAtIndexPath:&lt;/code&gt;中尽量不使用&lt;code&gt;cellForRowAtIndexPath:&lt;/code&gt;，如果你需要用到它，最好只用一次然后缓存结果。
    
    </summary>
    
    
      <category term="性能优化" scheme="http://wonkeyz.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="UITableView" scheme="http://wonkeyz.com/tags/UITableView/"/>
    
      <category term="UIWebView" scheme="http://wonkeyz.com/tags/UIWebView/"/>
    
      <category term="WKWebView" scheme="http://wonkeyz.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能优化UI篇（一）</title>
    <link href="http://wonkeyz.com/2017/06/24/iOS-Performance%20optimization-UI-1/"/>
    <id>http://wonkeyz.com/2017/06/24/iOS-Performance optimization-UI-1/</id>
    <published>2017-06-24T06:22:03.000Z</published>
    <updated>2017-10-26T09:16:53.935Z</updated>
    
    <content type="html"><![CDATA[<p> 这是一个老生常谈的话题，程序猿的一生除了在编译、写bug、改bug，就是在不断地重构优化，优化的点也多种多样，其中最直观有效的就是UI部分的优化了，这方面有很多相关资料，也有如<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYkit</a>、<a href="https://github.com/TextureGroup/Texture" target="_blank" rel="external">Texture</a>这种神级框架从根源上解决了卡顿的问题。作为菜鸟的我无法像大佬们一样从根源上分析解决UI性能问题，只能写一篇比较基础的文章，总结一下常用的控件的使用注意点，希望对你的日常开发有帮助~<br> <a id="more"></a></p><h3 id="基本法"><a href="#基本法" class="headerlink" title="基本法"></a>基本法</h3><p>先来一波UI操作的基本法则：</p><ul><li>尽量减少在主线程中的操作，避免阻塞主线程。执行的操作越多就意味着越高的丢帧率，从而导致丢帧卡顿。</li><li>尽量保持视图的扁平化，避免视图的多层嵌套。<br>只要给视图添加子视图，或其子视图布局发生变化都会触发父视图的<code>layoutSubviews</code>方法，如果一个视图被塞了很多子视图，性能消耗可想而知。那么这种情况如何避免呢？最好的方法是自定义视图绘制。这样只会触发一个视图的绘制方法，而不是多个子视图的，同时避免了父视图多次调用<code>layoutSubviews</code>和<code>drawRect:</code>方法，具体操作文中会给出demo。  </li><li>尽量使用不透明视图。<br>当一个view是透明的，iOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多subviews。这是一个非常耗时的过程。不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的<code>opaque</code>属性设为YES（默认值）。</li><li>一些情况下避免使用具有通用目的及功能丰富的控件，系统控件虽然方便，但有时也会带来不必要的消耗，你可以通过封装视图绘制内容来代替。如只显示大段纯文本，那么不必使用功能复杂的<code>UILabel</code>。</li><li>尽量延迟加载、重用复杂视图。<br>这点我相信大家在使用<code>UITableView</code>、<code>UICollectionView</code>时都深有体会，如果你对机制足够了解，那么在使用<code>UIScrollView</code>时也可以尝试使用重用机制。</li><li>尽量避免出现较大的xib或storyboard。sb固然强大，但整个XML文件在使用之前必须被解析和加载，所以应该最小化sb中的单元数目，创建多个sb或xib，这样不仅有助于减少应用启动时间，还能降低整体内存消耗。</li></ul><p>聊完基本法，我们来聊一下几个常见视图，看看有哪些性能小技巧。</p><h4 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h4><p>这绝对是你用的最多的控件，看似简单，但你真的了解它的性能消耗点吗？先来看看他有多复杂。<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-19/50317192.jpg" alt="图1"><br>图中的每一项设置都会增加<code>UILabel</code>的渲染代价，具体步骤如下：<br>1.使用字体样式及要被渲染的文本时，计算需要的像素数，这是一个消耗较大的过程，应尽量少做。<br>2.检查要被渲染的宽度。<br>3.检查<code>numberOfLines</code>，计算将要展示的行数。<br>4.<code>sizeToFit</code>是否被调用，调用则计算高度，未调用则检查当前尺寸是否能展示完整内容。<br>5.如果size不够展示，则使用<code>lineBreakMode</code>确定隐藏或截断的位置。<br>6.检查其他配置选项，如纯文本or富文本，富文本的样式，对齐方式，自动收缩等。<br>7.最后使用字体、类型及颜色等渲染最终显示的文本。<br>整个过程下来的渲染代价不容小觑，所以平时使用要避免一些不必要的性能浪费。<br>ps：有时会发现label的文字变模糊，那么你需要检查一下label的frame是否都为整数。</p><h4 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h4><p>按钮同样无处不在，样式多变、功能强大的它渲染方式主要有以下四种：</p><ul><li>使用自定义文本默认渲染</li><li>全尺寸资源渲染</li><li>可变尺寸资源渲染</li><li>使用<code>CALayer</code>和贝塞尔曲线自定义绘制</li></ul><p>下表简单列出了几种渲染方式的利弊。具体见<a href="https://robots.thoughtbot.com/designing-for-ios-taming-uibutton#advantages-of-bezier-approach" target="_blank" rel="external">Designing for iOS: Taming UIButton</a>。</p><table><thead><tr><th>渲染方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>自定义文本</td><td>简单易用</td><td>样式单一</td></tr><tr><td>全尺寸资源</td><td>可自定义背景图 <br> 样式多变 <br> 可实现A/B测试</td><td>图片导致ipa包变大</td></tr><tr><td>可变尺寸资源</td><td>ipa包大小增量较全尺寸小</td><td>资源的任何更改可能都会重新计算<code>UIEdgeInsets</code></td></tr><tr><td>自定义绘制</td><td>高度自定义样式</td><td>随着迭代代码回越发臃肿</td></tr></tbody></table><p>通过上面的比较，你需要权衡一下利弊，到底是要性能能还是要ipa包保持合适的大小。</p><h4 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h4><p>图像的使用也很简单，但在渲染代价较大的UI元素中，图像首屈一指。在使用UIImage、UIImageView时，注意以下几点有助于性能提升：</p><ul><li>加载图片的方式有三种<code>imageNamed:</code>、<code>imageWithContentsOfFile:</code>、<code>imageWithData:</code>，正确选择图片加载方式能够对内存优化起到很大的作用。<br><code>imageNamed:</code>优点在于可以缓存已经加载的图片，确保内容只被加载至内存一次，这对于图像的重复利用是非常有优势的。对于常用的小图推荐使用该方法，可以节省出每次都从磁盘加载图片的时间，这样能更好的响应用户的操作。<br><code>imageWithContentsOfFile:</code>和<code>imageWithData:</code>这两种方法的本质是一样的， 都是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到界面。一些不常用的大图推荐使用这两种方法，这样就不会缓存这些图片占用内存。</li><li>对于网络图像，使用高性能的图像缓存库，如<a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a>、<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>。</li><li>在图片格式的选择上同样很有讲究，选择合适的格式能够为你的应用带来最佳体验，这里奉上YY大神的博文<a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端图片格式调研</a>。</li><li>载入的图片与<code>UIImageView</code>尺寸相同。因为调整图片尺寸是一个性能消耗较大的操作，如果图像在<code>UIScrollView</code>中，则消耗更大。如果图片来自网络下载，那么尽量做到下载的图片与视图尺寸匹配，或者对图片进行预处理，调整尺寸。</li><li>在非主线程中解压JPG/PNG图片，最好在一个专用队列中执行。</li><li>在一些界面的实现上，确定是否真的需要图片。如展示一个评分控件<img src="http://owgqmweju.bkt.clouddn.com/17-10-20/33841778.jpg" alt="enter image description here">，那么最好通过直接绘制，调整透明度或覆盖来实现，而不是使用多张图片。类似情况的取舍既可以优化性能，还能给安装包瘦身。</li></ul><p>先总结到这里，下篇我会总结一些关于<code>UITableView</code>、<code>WebView</code>和自定义视图的性能优化点，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这是一个老生常谈的话题，程序猿的一生除了在编译、写bug、改bug，就是在不断地重构优化，优化的点也多种多样，其中最直观有效的就是UI部分的优化了，这方面有很多相关资料，也有如&lt;a href=&quot;https://github.com/ibireme/YYKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YYkit&lt;/a&gt;、&lt;a href=&quot;https://github.com/TextureGroup/Texture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Texture&lt;/a&gt;这种神级框架从根源上解决了卡顿的问题。作为菜鸟的我无法像大佬们一样从根源上分析解决UI性能问题，只能写一篇比较基础的文章，总结一下常用的控件的使用注意点，希望对你的日常开发有帮助~&lt;br&gt;
    
    </summary>
    
    
      <category term="性能优化" scheme="http://wonkeyz.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>仿Facebook点赞动画</title>
    <link href="http://wonkeyz.com/2017/06/20/Imitation-Facebook-point-like-animation/"/>
    <id>http://wonkeyz.com/2017/06/20/Imitation-Facebook-point-like-animation/</id>
    <published>2017-06-20T07:13:44.000Z</published>
    <updated>2017-11-22T06:24:04.903Z</updated>
    
    <content type="html"><![CDATA[<p>先写一个简单的动画练练手，效果如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-16/8652901.jpg" alt="图1"><br><a id="more"></a></p><h3 id="拆解动画"><a href="#拆解动画" class="headerlink" title="拆解动画"></a>拆解动画</h3><p>无论动画多复杂（虽然这个并不复杂😂），我相信都是由若干简单的动画组成的，下面来拆解一下这个动画，逐一实现效果自然就达到了~</p><ul><li>缩放动画</li><li>粒子动画</li></ul><h3 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h3><p>缩放动画实现起来很简单，这里用到了帧动画，直接上代码，一目了然~<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - Target Method</span></div><div class="line">- (<span class="keyword">void</span>)clickButtonAction &#123;</div><div class="line">    <span class="keyword">self</span>.selected = !<span class="keyword">self</span>.selected;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.selected) &#123;</div><div class="line">        [<span class="keyword">self</span> popOutside];</div><div class="line">        [_explodeView animate];</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> popInside];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Animate Methods</span></div><div class="line">- (<span class="keyword">void</span>)popInside &#123;</div><div class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">.5</span>f delay:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</div><div class="line">        </div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0</span></div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">.7</span>f, <span class="number">.7</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.</span>f, <span class="number">1.</span>f);</div><div class="line">                                      &#125;];</div><div class="line">    &#125; completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)popOutside &#123;</div><div class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">.5</span>f delay:<span class="number">0</span> options: <span class="built_in">UIViewKeyframeAnimationOptionCalculationModeCubicPaced</span> animations: ^&#123;</div><div class="line">        </div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0</span></div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">.8</span>f, <span class="number">.8</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">2</span> / <span class="number">3.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.</span>f, <span class="number">1.</span>f);</div><div class="line">                                      &#125;];</div><div class="line">    &#125; completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="粒子动画"><a href="#粒子动画" class="headerlink" title="粒子动画"></a>粒子动画</h3><p>这个爆炸效果是不是看起来很眼熟？没错其实它跟烟花、下雪的动画实现是一样的，都用到了<code>CALayer</code>的一个高性能原生粒子引擎<a href="https://developer.apple.com/documentation/quartzcore/caemitterlayer" target="_blank" rel="external">CAEmitterLayer</a>。<br>简单介绍一下<code>CAEmitterLayer</code>，<code>CAEmitterLayer</code>相当于<code>CAEmitterCell</code>的容器，每一个cell相当于一个粒子，我们只需要定义一个<code>CAEmitterCell</code>粒子效果来作为粒子样式模板，比如粒子的图片、生成率、生命周期等参数，<code>CAEmitterLayer</code>会基于模板实例化该样式的粒子流，根据设置好的发射位置、发射模式、形状使他们动起来。具体代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setupEmitterLayer &#123;</div><div class="line">    <span class="keyword">self</span>.clipsToBounds = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//创建粒子</span></div><div class="line">    <span class="built_in">CAEmitterCell</span> *emitter = [<span class="built_in">CAEmitterCell</span> emitterCell];</div><div class="line">    emitter.contents        = (<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"like_dot"</span>].CGImage;</div><div class="line">    emitter.name            = <span class="string">@"emitterCell"</span>;</div><div class="line">    emitter.birthRate       = <span class="number">0</span>;</div><div class="line">    emitter.lifetime        = <span class="number">.7</span>f;</div><div class="line">    emitter.lifetimeRange   = <span class="number">.3</span>f;</div><div class="line">    emitter.alphaRange      = <span class="number">.2</span>f;</div><div class="line">    emitter.alphaSpeed      = <span class="number">-1.</span>f;</div><div class="line">    emitter.velocity        = <span class="number">40.</span>f;</div><div class="line">    emitter.velocityRange   = <span class="number">10.</span>f;</div><div class="line">    emitter.emissionRange   = M_PI_4;</div><div class="line">    emitter.scale           = <span class="number">.05</span>f;</div><div class="line">    emitter.scaleRange      = <span class="number">.02</span>f;</div><div class="line">    </div><div class="line">    <span class="comment">//创建粒子图层</span></div><div class="line">    _emitterLayer = [<span class="built_in">CAEmitterLayer</span> layer];</div><div class="line">    _emitterLayer.name              = <span class="string">@"emitterLayer"</span>;</div><div class="line">    _emitterLayer.frame             = <span class="keyword">self</span>.bounds;</div><div class="line">    _emitterLayer.emitterShape      = kCAEmitterLayerCircle;</div><div class="line">    _emitterLayer.emitterMode       = kCAEmitterLayerOutline;</div><div class="line">    _emitterLayer.emitterPosition   = <span class="keyword">self</span>.center;</div><div class="line">    _emitterLayer.emitterSize       = <span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">0</span>);</div><div class="line">    _emitterLayer.renderMode        = kCAEmitterLayerOldestFirst;</div><div class="line">    _emitterLayer.masksToBounds     = <span class="literal">NO</span>;</div><div class="line">    _emitterLayer.emitterCells      = @[emitter];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer: _emitterLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Public Methods</span></div><div class="line">- (<span class="keyword">void</span>)animate &#123;</div><div class="line">    [_emitterLayer removeAnimationForKey:<span class="string">@"likeAnimation"</span>];</div><div class="line">    dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, <span class="number">.2</span>f * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">self</span>.emitterLayer.beginTime = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        <span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath: <span class="string">@"emitterCells.emitterCell.birthRate"</span>];</div><div class="line">        animation.fromValue = @<span class="number">0</span>;</div><div class="line">        animation.toValue = @<span class="number">600</span>;</div><div class="line">        [_emitterLayer addAnimation:animation forKey:<span class="string">@"likeAnimation"</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>搞定！如果对帧动画和粒子动画有疑问可以看下面两篇文章：<br><a href="http://www.jianshu.com/p/a071bba99a1b" target="_blank" rel="external">Transform和KeyFrame动画</a><br><a href="https://segmentfault.com/a/1190000008580771" target="_blank" rel="external">CAEmitterLayer和CAEmitterCell的基本用法</a></p><p>demo地址：<a href="https://github.com/zhangMax/WZLikeButton" target="_blank" rel="external">WZLikeButton</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先写一个简单的动画练练手，效果如图：&lt;br&gt;&lt;img src=&quot;http://owgqmweju.bkt.clouddn.com/17-10-16/8652901.jpg&quot; alt=&quot;图1&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="animation" scheme="http://wonkeyz.com/tags/animation/"/>
    
  </entry>
  
  <entry>
    <title>Stay hungry, Stay foolish.</title>
    <link href="http://wonkeyz.com/2017/06/13/Stay-hungry-Stay-foolish/"/>
    <id>http://wonkeyz.com/2017/06/13/Stay-hungry-Stay-foolish/</id>
    <published>2017-06-13T08:11:03.000Z</published>
    <updated>2017-10-19T07:13:24.645Z</updated>
    
    <content type="html"><![CDATA[<p>做了一年多iOS开发的菜鸟一只，平时喜欢看各种大佬的博客，获益良多，但随着年龄的增长，记性越来越差…看过的东西如果不记在小本本上，怕不是要忘光…所以弄了个博客，记录平时工作中遇到的坑，以及拜读大佬博客的一些‘‘领悟’’，希望自己能坚持下去，也希望能给大家带来一些帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做了一年多iOS开发的菜鸟一只，平时喜欢看各种大佬的博客，获益良多，但随着年龄的增长，记性越来越差…看过的东西如果不记在小本本上，怕不是要忘光…所以弄了个博客，记录平时工作中遇到的坑，以及拜读大佬博客的一些‘‘领悟’’，希望自己能坚持下去，也希望能给大家带来一些帮助。&lt;/p
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://wonkeyz.com/tags/iOS/"/>
    
  </entry>
  
</feed>
