<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[适配iOS11&iPhoneX的一些坑]]></title>
      <url>/2017/09/17/%E9%80%82%E9%85%8DiOS11-iPhoneX%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>前阵子项目开发忙成狗，就一直没做iOS11的适配，直到XcodeGM版发布后，我胸有成竹的在iPhoneX上跑起项目，整个人都凉透了…下面总结一下我遇到的坑，不是很全面，日后补充。</p>
<a id="more"></a>
<h3 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h3><h4 id="导航栏高度的变化"><a href="#导航栏高度的变化" class="headerlink" title="导航栏高度的变化"></a>导航栏高度的变化</h4><p>iOS11之前导航栏默认高度为64pt(<strong>这里高度指statusBar + NavigationBar</strong>)，iOS11之后如果设置了<code>prefersLargeTitles = YES</code>则为96pt，默认情况下还是64pt，但在iPhoneX上由于刘海的出现statusBar由以前的20pt变成了44pt，所以iPhoneX上高度变为88pt，如果项目里隐藏了导航栏加了自定义按钮之类的，这里需要注意适配一下。</p>
<h4 id="导航栏图层及对titleView布局的影响"><a href="#导航栏图层及对titleView布局的影响" class="headerlink" title="导航栏图层及对titleView布局的影响"></a>导航栏图层及对titleView布局的影响</h4><p>iOS11之前导航栏的title是添加在<code>UINavigationItemView</code>上面，而navigationBarButton则直接添加在<code>UINavigationBar</code>上面，如果设置了titleView，则titleView也是直接添加在<code>UINavigationBar</code>上面。iOS11之后，大概因为<code>largeTitle</code>的原因，视图层级发生了变化，如果没有给titleView赋值，则titleView会直接添加在<code>_UINavigationBarContentView</code>上面，如果赋值了titleView，则会把titleView添加在<code>_UITAMICAdaptorView</code>上，而navigationBarButton被加在了<code>_UIButtonBarStackView</code>上，然后他们都被加在了<code>_UINavigationBarContentView</code>上，如图：<br><img src="http://upload-images.jianshu.io/upload_images/702870-11488fe68c9d145b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br>所以如果你的项目是自定义的navigationBar，那么在iOS11上运行就可能出现布局错乱的bug，解决办法是重写<code>UINavigationBar</code>的<code>layoutSubviews</code>方法，调整布局，上代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</div><div class="line">    [<span class="keyword">super</span> layoutSubviews];</div><div class="line"></div><div class="line">    <span class="comment">//注意导航栏及状态栏高度适配</span></div><div class="line">    <span class="keyword">self</span>.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">CGRectGetWidth</span>(<span class="keyword">self</span>.frame), naviBarHeight);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span>.subviews) &#123;</div><div class="line">        <span class="keyword">if</span>([<span class="built_in">NSStringFromClass</span>([view <span class="keyword">class</span>]) containsString:<span class="string">@"Background"</span>]) &#123;</div><div class="line">            view.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>([view <span class="keyword">class</span>]) containsString:<span class="string">@"ContentView"</span>]) &#123;</div><div class="line">            <span class="built_in">CGRect</span> frame = view.frame;</div><div class="line">            frame.origin.y = statusBarHeight;</div><div class="line">            frame.size.height = <span class="keyword">self</span>.bounds.size.height - frame.origin.y;</div><div class="line">            view.frame = frame;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再补充一点，看了<a href="http://www.jianshu.com/p/26fc39135c34" target="_blank" rel="external">简书App适配iOS11</a>发现titleView支持<code>autolayout</code>，这要求titleView必须是能够自撑开的或实现了<code>- intrinsicContentSize</code>方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UILayoutFittingExpandedSize</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="继承自UIScrollView的视图偏移问题"><a href="#继承自UIScrollView的视图偏移问题" class="headerlink" title="继承自UIScrollView的视图偏移问题"></a>继承自UIScrollView的视图偏移问题</h3><p>大家在iOS11设备上运行出现最多问题应该就是<code>tableview</code>莫名奇妙的偏移20pt或者64pt了。。原因是iOS11弃用了<code>automaticallyAdjustsScrollViewInsets</code>属性，取而代之的是<code>UIScrollView</code>新增了<code>contentInsetAdjustmentBehavior</code>属性，这一切的罪魁祸首都是新引入的<code>safeArea</code>，关于<code>safeArea</code>适配这篇文章<a href="http://www.jianshu.com/p/efbc8619d56b" target="_blank" rel="external">iOS 11 安全区域适配总结</a>讲的很详细，感兴趣的可以看下，我直接贴适配代码，因为低版本直接用<code>contentInsetAdjustmentBehavior</code>会报警告，所有定义了如下的宏（感谢<a href="http://www.jianshu.com/u/634f3d1c7c22" target="_blank" rel="external">@炒鸡范</a>的指正，之前的宏犯了个低级错误…现改为）<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define  adjustsScrollViewInsets(scrollView)\</span></div><div class="line"><span class="keyword">do</span> &#123;\</div><div class="line">_Pragma(<span class="string">"clang diagnostic push"</span>)\</div><div class="line">_Pragma(<span class="string">"clang diagnostic ignored \"-Warc-performSelector-leaks\""</span>)\</div><div class="line"><span class="keyword">if</span> ([scrollView respondsToSelector:<span class="built_in">NSSelectorFromString</span>(<span class="string">@"setContentInsetAdjustmentBehavior:"</span>)]) &#123;\</div><div class="line"><span class="built_in">NSMethodSignature</span> *signature = [<span class="built_in">UIScrollView</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(setContentInsetAdjustmentBehavior:)];\</div><div class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];\</div><div class="line"><span class="built_in">NSInteger</span> argument = <span class="number">2</span>;\</div><div class="line">invocation.target = scrollView;\</div><div class="line">invocation.selector = <span class="keyword">@selector</span>(setContentInsetAdjustmentBehavior:);\</div><div class="line">[invocation setArgument:&amp;argument atIndex:<span class="number">2</span>];\</div><div class="line">[invocation retainArguments];\</div><div class="line">[invocation invoke];\</div><div class="line">&#125;\</div><div class="line">_Pragma(<span class="string">"clang diagnostic pop"</span>)\</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>还有的发现某些界面<code>tableView</code>的<code>sectionHeader</code>、<code>sectionFooter</code>高度与设置不符的问题，在iOS11中如果不实现 <code>-tableView: viewForHeaderInSection:</code>和<code>-tableView: viewForFooterInSection:</code> ，则<code>-tableView: heightForHeaderInSection:</code>和<code>- tableView: heightForFooterInSection:</code>不会被调用，导致它们都变成了默认高度，这是因为<code>tableView</code>在iOS11默认使用<code>Self-Sizing</code>，<code>tableView</code>的<code>estimatedRowHeight</code>、<code>estimatedSectionHeaderHeight</code>、 <code>estimatedSectionFooterHeight</code>三个高度估算属性由默认的0变成了<code>UITableViewAutomaticDimension</code>，解决办法简单粗暴，就是在对应界面实现对应方法或把<code>tableView</code>的这三个属性设为0。如果你想全局关闭<code>Self-Sizing</code>可使用下面这段代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedRowHeight = <span class="number">0</span>; </div><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedSectionFooterHeight = <span class="number">0</span>;</div><div class="line"><span class="built_in">UITableView</span>.appearance.estimatedSectionHeaderHeight = <span class="number">0</span>;</div></pre></td></tr></table></figure></p>
<p>如果你使用了<code>Masonry</code>，某些界面需要适配需要适配<code>safeArea</code>，可以试试下面这段代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</div><div class="line">    make.edges.equalTo()(<span class="keyword">self</span>.view.safeAreaInsets)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    make.edges.equalTo()(<span class="keyword">self</span>.view)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="相册访问权限"><a href="#相册访问权限" class="headerlink" title="相册访问权限"></a>相册访问权限</h3><p>看其他适配文章上对iOS11相册权限调整的说明是“iOS11把 <a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW17" target="_blank" rel="external">NSPhotoLibraryUsageDescription</a> 替换成了<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW73" target="_blank" rel="external">NSPhotoLibraryAddUsageDescription</a>”，奇怪的是我的项目并没有添加<code>NSPhotoLibraryAddUsageDescription</code>，在访问相册时也没发生crash，后来在仔细阅读了官方文档才发现<code>NSPhotoLibraryAddUsageDescription</code>只针对相册存储权限，在iOS11上系统默认打开了用户相册的访问权限，如果应用需要存储权限就需要添加这个key，否则就会crash。</p>
<h3 id="AppIcon"><a href="#AppIcon" class="headerlink" title="AppIcon"></a>AppIcon</h3><p>在iOS11上发现了一个奇怪的现象，APP在启动图标会出现黑边，如图（处女座实在忍不了…）<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-23/31263530.jpg" alt="图2"><br>原因是iOS11修改了App启动动画，如果你的App图标有圆角那么就会变成这个鸟样了…所有图标都换成直角就好了，具体规范见<a href="https://developer.apple.com/design/" target="_blank" rel="external">Human Interface Guidelines-App Icon</a>，还是要听苹果爸爸的话啊…</p>
<h3 id="iPhoneX"><a href="#iPhoneX" class="headerlink" title="iPhoneX"></a>iPhoneX</h3><h4 id="LaunchImage"><a href="#LaunchImage" class="headerlink" title="LaunchImage"></a>LaunchImage</h4><p>关于iPhoneX(我就不吐槽刘海了…)，如果你的APP在iPhoneX上运行发现没有充满屏幕，上下有黑色区域，那么你应该也像我一样<code>LaunchImage</code>没有用<code>storyboard</code>而是用的<code>Assets</code>，解决办法如图，启动图的尺寸为<code>1125x2436</code>，or you can <a href="http://www.jianshu.com/p/77054dccafdb" target="_blank" rel="external">iOS开发时如何使用 Launch Screen Storyboard</a>。<br><img src="http://upload-images.jianshu.io/upload_images/702870-71705661b4518de5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>
<h4 id="TabBarController"><a href="#TabBarController" class="headerlink" title="TabBarController"></a>TabBarController</h4><p>如果你使用了原生tabBar，系统会自动适配，因为我们的项目用了第三方的<code>TabBarController</code>，在iPhoneX运行，tabBar看起来怪怪的(<strong>如果不确定你的项目tabBar在iPhoneX上看起来是否正常，可以参照模拟器的照片APP，一看便知</strong>)…估计作者要等到猴年马月才适配iPhoneX，项目又着急上线，就自己改了下，主要是<code>tabBar</code>高度及<code>tabBarItem</code>偏移适配，iPhoneX由于底部安全区的原因<code>UITabBar</code>高度由49pt变成了83pt，多出来的34pt是空白手势区域。可以通过判断机型来修改相关界面代码，方式有两种，通过分辨率判断：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define kDevice_Is_iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)</span></div></pre></td></tr></table></figure></p>
<p>通过设备名称判断：<br>@”iPhone10,1” : @”iPhone 8”,<br>@”iPhone10,4” : @”iPhone 8”,<br>@”iPhone10,2” : @”iPhone 8 Plus”,<br>@”iPhone10,5” : @”iPhone 8 Plus”,<br>@”iPhone10,3” : @”iPhone X”,<br>@”iPhone10,6” : @”iPhone X”,<br>这里推荐使用<a href="https://github.com/squarefrog/UIDeviceIdentifier" target="_blank" rel="external">UIDeviceIdentifier</a>。</p>
<p>目前遇到的就这些坑，欢迎大家指正补充~</p>
<p>作为一名iOS开发人员，想到当年嘲笑Android开发蛋疼的适配各种机型心情如图…<br><img src="http://upload-images.jianshu.io/upload_images/702870-4db780c96ed7f4b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>最后奉上WWDC官方视频：</p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="external">Updating Your App for iOS 11</a></p>
<p><a href="https://developer.apple.com/videos/play/fall2017/201/" target="_blank" rel="external">Building Apps for iPhone X</a></p>
<p><a href="https://developer.apple.com/videos/play/fall2017/801/" target="_blank" rel="external">Designing for iPhone X</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 适配iOS11 </tag>
            
            <tag> 适配iPhoneX </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在对象dealloc时做一些操作]]></title>
      <url>/2017/07/28/%E5%9C%A8%E5%AF%B9%E8%B1%A1dealloc%E6%97%B6%E5%81%9A%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>最近做直播间优化时遇到个奇葩需求，需要在评论输入视图释放时做一些操作，当时没想太多直接在CommentView外部公开一个block，然后在CommentView的<code>dealloc</code>方法里调用该block，简单粗暴…<a id="more"></a>事后想了想能不能封装一个通用的方法给对象添加一个释放时调用的block呢？第一时间想到用Method Swizzling来hook对象的<code>dealloc</code>方法，马上领悟到这样未免侵入性太强，日后也许会导致难以排查的bug，仔细思考后想到了一个巧妙的方法，通过Category给<code>NSObject</code>公开一个添加block的方法，利用runtime的AssociatedObject给对象搭配一个‘‘小伙伴’’，在对象释放时，这个‘‘小伙伴’’负责调用block，这样既做到了与对象的共存亡又简单干净，上代码~<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^DeallocBlock)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Associate</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">给对象添加释放时调用的block</div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)addDeallocBlock:(DeallocBlock)deallocBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"NSObject+Associate.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Partner</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) DeallocBlock deallocBlock;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Partner</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    <span class="keyword">if</span> (_deallocBlock) &#123;</div><div class="line">        _deallocBlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">void</span> *kPartnerArrayKey = &amp;kPartnerArrayKey;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Associate</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addDeallocBlock:(DeallocBlock)deallocBlock &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> *partnerArray = objc_getAssociatedObject(<span class="keyword">self</span>, kPartnerArrayKey);</div><div class="line">        <span class="keyword">if</span> (!partnerArray) &#123;</div><div class="line">            partnerArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, kPartnerArrayKey, partnerArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">        &#125;</div><div class="line">        Partner *partner = [[Partner alloc] init];</div><div class="line">        partner.deallocBlock = deallocBlock;</div><div class="line">        [partnerArray addObject:partner];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这里有几点<strong>注意事项</strong>：<br>1.block触发时的线程与对象释放时的线程一致，注意后续操作的线程安全。<br>2.如果你想在block里引用对象，那么无论强弱引用都是不可行的，强引用会造成循环引用，弱引用则获取不到对象，因为已经被至为nil，可以使用<code>__unsafe_unretained</code>修饰：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) unsafeSelf = <span class="keyword">self</span>;</div></pre></td></tr></table></figure></p>
<p>现在看起来比最开始的直接在CommentView的dealloc里做操作的想法成熟多了，但之后我再查阅相关资料时还是发现自己<em>too young too native</em>了…其实早就有大佬写了类似的框架，放个链接供大家膜<a href="https://github.com/ChenYilong/CYLDeallocBlockExecutor#%E4%BD%BF%E7%94%A8cyldeallocblockexecutor" target="_blank" rel="external">CYLDeallocBlockExecutor</a>，代码不是很复杂，但是考虑的点和实现思路很赞，也许这就是差距吧…其中涉及到了<code>NSHashTable</code>，不了解的可以看南大的<a href="http://southpeak.github.io/2015/05/10/ios-techset-1/" target="_blank" rel="external">iOS知识小集 第1期(2015.05.10)-NSHashTable部分</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> runitme </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Runtime学习总结（一）]]></title>
      <url>/2017/07/09/Runtime%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><code>Runtime</code>在业内有iOS开发‘‘黑科技’’之称，但在平时开发中也就接触了<code>Method Swizzling</code>，<code>AssociatedObject</code>这几种应用，用了这么久OC，却对它的内在一无所知，实在说不过去…今天我来总结一下最近学习<code>runtime</code>的知识点，看看它究竟‘‘黑’’在哪里。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们都知道Objective-C是一门动态语言，可以在程序运行时创建，检查，修改类、对象和它们的方法，这一切都归功于<code>runtime</code>，它是用C和汇编写的库，这个库使C具有了面向对象的能力。总结起来，<code>Runtime</code>库主要做了几件事:</p>
<ul>
<li>封装：用C的结构体表示OC的对象，用C的函数实现OC的方法，这些结构体和函数被<code>runtime</code>函数封装后，OC就具有了动态的特性。</li>
<li>收发消息：在对象执行某个方法时，这个方法被<code>runtime</code>当做一条消息发送给接收者，也就是对象，<code>Runtime</code>会根据接收者能否响应该消息而做出不同的反应。  </li>
</ul>
<p>下面我们分别来看下平时再熟悉不过的类与对象、成员变量与属性的数据结构和操作函数。<br><a id="more"></a></p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>通过<code>objc.h</code>与<code>runtime.h</code>我们可以看到<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里定义了一个指向objc_class结构体的指针Class，也就是OC中的类</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line"><span class="comment">// 结构体定义如下</span></div><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">    </div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                   	OBJC2_UNAVAILABLE;	<span class="comment">// 父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                      	OBJC2_UNAVAILABLE;	<span class="comment">// 类名</span></div><div class="line">    <span class="keyword">long</span> version                          	OBJC2_UNAVAILABLE;	<span class="comment">// 类版本，默认为0</span></div><div class="line">    <span class="keyword">long</span> info                            	OBJC2_UNAVAILABLE;	<span class="comment">// 类信息，供运行时使用的一些位标识</span></div><div class="line">    <span class="keyword">long</span> instance_size                   	OBJC2_UNAVAILABLE;	<span class="comment">// 实例变量大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars         	OBJC2_UNAVAILABLE;	<span class="comment">// 成员变量列表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists 	OBJC2_UNAVAILABLE;	<span class="comment">// 方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache              	OBJC2_UNAVAILABLE;	<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols 	OBJC2_UNAVAILABLE;	<span class="comment">// 协议列表</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>我们先来看下这几个字段：</p>
<ul>
<li><code>isa</code>：我们知道OC中对象的<code>isa</code>指向类，同样类也有一个<code>isa</code>指针，它指向<code>meta Class</code>(元类)，这里类也是一个对象。</li>
<li><code>super_class</code>：指向该类的父类，如果该类已经是<code>Root Class</code>(如<code>NSObject</code>或<code>NSProxy</code>)，则<code>super_class</code>为<code>NULL</code>。</li>
<li><p><code>cache</code>：该字段用于缓存调用过的方法。<code>cache</code>指针指向<code>objc_cache</code>结构体，这个结构体的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span> OBJC2_UNAVAILABLE; <span class="comment">// 指定分配缓存bucket的总数。runtime使用这个字段确定线性查找数组的索引位置</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied OBJC2_UNAVAILABLE; <span class="comment">// 实际占用缓存bucket总数</span></div><div class="line">    Method buckets[<span class="number">1</span>] OBJC2_UNAVAILABLE; <span class="comment">// 指向Method数据结构指针的数组，这个数组的元素总数不能超过mask+1，如果为空则表示缓存bucket没有被占用，它有可能是不连续的，会随着时间而变大。</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>当我们调用一个方法时，这个方法就会被放到<code>cache</code>中，下次调用<code>runtime</code>就会优先去<code>cache</code>中查找，这样就避免了每次都直接去<code>methodLists</code>中查找，提高了效率。</p>
</li>
</ul>
<h4 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h4><p>看完了<code>Class</code>我们再来看一下对象，参考<code>objc-private.h</code>部分源码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">private:</div><div class="line">    isa_t isa;</div><div class="line"></div><div class="line">public:</div><div class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></div><div class="line">    Class ISA();</div><div class="line"></div><div class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></div><div class="line">    Class getIsa();</div><div class="line"></div><div class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></div><div class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></div><div class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></div><div class="line">    <span class="comment">// initClassIsa(): class objects</span></div><div class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></div><div class="line">    <span class="comment">// initIsa(): other objects</span></div><div class="line">    <span class="keyword">void</span> initIsa(Class cls <span class="comment">/*nonpointer=false*/</span>);</div><div class="line">    <span class="keyword">void</span> initClassIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</div><div class="line">    <span class="keyword">void</span> initProtocolIsa(Class cls <span class="comment">/*nonpointer=maybe*/</span>);</div><div class="line">    <span class="keyword">void</span> initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor);</div><div class="line">    <span class="comment">// 省略其他方法声明...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure></p>
<p><code>objc_object</code>结构体包含一个类型为<code>isa_t</code>的<code>isa</code>指针，这个指针就是我们所说的指向这个对象所属类的指针。publich里面定义了一些操作<code>isa</code>的方法。<code>Runtime</code>库会在该类的方法列表及父类的方法列表中去寻找与消息对应的<code>selector</code>，找到后即执行这个方法。<br>下面的<code>id</code>是一个<code>objc_object</code>结构体类型的指针，这个类型的对象能够转换成任意类型的对象，类似于C语言中void *指针的作用。<br>这里有一点要特殊说明，其实<code>isa</code>并不总是指向实例对象所属的类，在我们使用KVO时，会产生一个中间类，系统会通过<code>isa-swizzling</code>把<code>isa</code>指向这个类而不是真实的类，所以不能依靠它来确定类型，而应该用<code>class</code>方法来确定实例对象的类。详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">官方文档</a>。</p>
<h4 id="Meta-Class"><a href="#Meta-Class" class="headerlink" title="Meta Class"></a>Meta Class</h4><p>上面我们说到类本身也是对象，那么他的<code>isa</code>指向谁呢？答案就是元类<code>Meta Class</code>。当我们向一个对象发送消息时，<code>runtime</code>会在这个对象所属类的方法列表中查找方法，而向一个类发送消息时，会在这个类的<code>Meta Class</code>的方法列表中查找。<br><code>Meta Class</code>存储着一个类的所有类方法，每个类都会有一个单独的<code>Meta Class</code>，因为每个类的类方法基本不可能完全相同。<br>那么问题来了，<code>Meta Class</code>的<code>isa</code>又指向谁呢？这么搞下去岂不是无穷无尽…为了避免这种尴尬的问题，Objective-C的设计者让所有<code>Meta Class</code>的<code>isa</code>都指向基类（Root Class）的<code>Meta Class</code>，即所有的类的<code>Meta Class</code>，包括Root Class，Superclass，Subclass的<code>isa</code>都指向Root class的<code>Meta Class</code>，而Root Class的<code>Meta Class</code>的<code>isa</code>指针又指向了它自己，这样就形成一个闭环。如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-11-17/86473124.jpg" alt="图1"><br>再来一个小demo来验证一下上图（取自<a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="external">神经病院objc runtime入院考试</a>）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">          <span class="built_in">BOOL</span> res1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res3 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">BOOL</span> res4 = [(<span class="keyword">id</span>)[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line">          <span class="built_in">NSLog</span>(<span class="string">@"%d %d %d %d"</span>, res1, res2, res3, res4);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 结果为1 0 0 0</span></div></pre></td></tr></table></figure></p>
<p>先来看下<code>isKindOfClass:</code>,<code>isMemberOfClass:</code>在<code>Object.mm</code>中的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass &#123;</div><div class="line">     Class cls;</div><div class="line">     <span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass)</div><div class="line">          <span class="keyword">if</span> (cls == (Class)aClass)</div><div class="line">               <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass &#123;</div><div class="line">     <span class="keyword">return</span> isa == (Class)aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们从头走一遍，res1第一次cls是NSObject的Meta Class，因为他是基类，所有第二次cls又指回了NSObject，返回YES；res2只走了一次返回NO；res3第一次cls是Sark的Meta Class，第二次cls是NSObject的Meta Class，第三次cls是NSObject，返回NO；res4显然返回NO。</p>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="类操作函数"><a href="#类操作函数" class="headerlink" title="类操作函数"></a>类操作函数</h4><p>聊完类与对象的基本结构，我们来看下都可以对它们做哪些操作。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"><span class="comment">// 获取元类</span></div><div class="line">Class objc_getMetaClass( Class cls );</div><div class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div><div class="line"></div><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div><div class="line"></div><div class="line"><span class="comment">// 成员变量操作函数</span></div><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types ); </div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 属性操作函数</span></div><div class="line"><span class="comment">// 获取指定的属性</span></div><div class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取属性列表</span></div><div class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 添加属性</span></div><div class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"><span class="comment">// 替换类的属性</span></div><div class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"></div><div class="line"><span class="comment">// 协议操作函数</span></div><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<p><code>Objective-C</code>不支持往已存在的类中添加成员，因此不管是系统库提供的类，还是我们自定义的类，都无法动态添加成员变量。所以<code>class_addIvar</code>只支持给运行时创建的非元类添加成员变量，还需要注意这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。<br>类似于<code>class_copyIvarList</code>,<code>class_getClassVariable</code>的函数返回的数组在使用后需要使用free()手动释放，<code>outCount</code>指针返回数组的大小。<br><code>class_conformsToProtocol</code>相当于<code>conformsToProtocol:</code>方法。  </p>
<h4 id="对象操作函数"><a href="#对象操作函数" class="headerlink" title="对象操作函数"></a>对象操作函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div><div class="line"></div><div class="line"><span class="comment">// 修改对象实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 修改对象实例变量的值，如果Ivar已知，则调用该函数会比object_setInstanceVariable快，下面一样</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"></div><div class="line"><span class="comment">// 返回对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure>
<p>举一个简单的例子，在运行时转换对象的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p>
<h4 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h4><h5 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes ); <span class="comment">// 如果创建的是root class，则superclass为Nil。extraBytes通常为0</span></div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls ); <span class="comment">// 如果程序中还存在该类或子类的实例，就不能够调用该方法。</span></div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls ); <span class="comment">// 创建了新类后，使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类。</span></div></pre></td></tr></table></figure>
<p>代码示例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line"></div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line"></div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line"></div><div class="line">objc_registerClassPair(cls);</div><div class="line"></div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div><div class="line"></div><div class="line"><span class="comment">// 输出结果均为run sub method 1</span></div></pre></td></tr></table></figure></p>
<h5 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj ); <span class="comment">// 不会释放移除任何与该实例相关的引用</span></div></pre></td></tr></table></figure>
<p><code>class_createInstance</code>：创建实例时，会在默认的内存区域为类分配内存，无法在ARC环境下使用。这里延伸一个知识点<a href="http://www.jianshu.com/p/bab5e34e5ff0" target="_blank" rel="external">深入理解alloc、init方法</a>，<code>class_createInstance</code>效果与<code>alloc</code>方法类似，我们来对比一下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"> </div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 输出结果为NSString,__NSCFConstantString</span></div></pre></td></tr></table></figure></p>
<p>在使用<code>objc_destructInstance</code>函数时并不会释放并移除任何与其相关的引用。</p>
<h4 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"></div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure>
<h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p><code>Ivar</code>表示实例变量的类型，指向<code>objc_ivar</code>结构体的指针，<code>ivar</code>指针地址是根据<code>class</code>结构体的地址加上基地址偏移字节得到的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name               	OBJC2_UNAVAILABLE;	<span class="comment">// 变量名</span></div><div class="line">    <span class="keyword">char</span> *ivar_type             	OBJC2_UNAVAILABLE;	<span class="comment">// 变量类型</span></div><div class="line">    <span class="keyword">int</span> ivar_offset            		OBJC2_UNAVAILABLE;	<span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                 		OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="objc-property-t、objc-property-attribute-t"><a href="#objc-property-t、objc-property-attribute-t" class="headerlink" title="objc_property_t、objc_property_attribute_t"></a>objc_property_t、objc_property_attribute_t</h4><p><code>objc_property_t</code>：声明的属性的类型，是一个指向objc_property结构体的指针：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div><div class="line">```  </div><div class="line">`objc_property_attribute_t`：定义了属性的特性的结构体：</div><div class="line">```objc</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 属性特性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 属性特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure></p>
<p>列举一些常用的attribure：</p>
<table>
<thead>
<tr>
<th>attribure</th>
<th>name</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>nonatomic</td>
<td>N</td>
<td>空</td>
</tr>
<tr>
<td>strong/retain</td>
<td>&amp;</td>
<td>空</td>
</tr>
<tr>
<td>weak</td>
<td>W</td>
<td>空</td>
</tr>
<tr>
<td>copy</td>
<td>C</td>
<td>空</td>
</tr>
<tr>
<td>属性的类型type</td>
<td>T</td>
<td>@”TypeName”, 如 @”NSString”</td>
</tr>
<tr>
<td>属性对应的实例变量Ivar</td>
<td>V</td>
<td>Ivar_name, 如 _name</td>
</tr>
<tr>
<td>readonly</td>
<td>R</td>
<td>空</td>
</tr>
<tr>
<td>getter</td>
<td>G</td>
<td>GetterName, 如 isHighlight</td>
</tr>
<tr>
<td>setter</td>
<td>S</td>
<td>SetterName, 如 setName</td>
</tr>
<tr>
<td>assign/atomic</td>
<td>默认即为assign和atomic</td>
<td>空</td>
</tr>
</tbody>
</table>
<h3 id="操作函数-1"><a href="#操作函数-1" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure>
<p>关于类型编码，感兴趣的可以看下官方文档<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encodings</a>、<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a>。</p>
<h4 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h4><p>如果在开发中你准备给系统的类额外添加一个属性，你可能会想到使用继承来实现，但是只增加一个属性，就去继承一个类，未免太麻烦了。这个时候，runtime提供了一个解决方案：即关联对象(Associated Object)。函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div></pre></td></tr></table></figure></p>
<p>其中参数含义为：<br>1.<code>id object</code>给谁添加关联对象。<br>2.<code>const void *key</code>关联对象唯一的key，获取时会用到。<br>3.<code>id value</code>关联对象。<br>4.<code>objc_AssociationPolicy</code>关联策略，有以下几种策略：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, </div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span> </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据要关联对象的类型来选择关联策略。有了上面三个函数，我们就可以给分类添加/移除关联对象了，简单代码实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加关联对象（可以用方法地址作为key）</span></div><div class="line">- (<span class="keyword">void</span>)addAssociatedObject:(<span class="keyword">id</span>)object&#123;</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(getAssociatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取关联对象（_cmd代表当前调用方法的地址）</span></div><div class="line">- (<span class="keyword">id</span>)getAssociatedObject&#123;</div><div class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<p>实例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">objc_property_t * properties = class_copyPropertyList([Model <span class="keyword">class</span>], &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</div><div class="line">    objc_property_t property = properties[i];</div><div class="line">    <span class="comment">//属性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name = property_getName(property);</div><div class="line">    <span class="comment">//属性描述</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * propertyAttr = property_getAttributes(property);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"属性 %s 的描述为 %s"</span>, name, propertyAttr);</div><div class="line"></div><div class="line">    <span class="comment">//属性的特性</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attrCount = <span class="number">0</span>;</div><div class="line">    objc_property_attribute_t * attrs = property_copyAttributeList(property, &amp;attrCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; attrCount; j ++) &#123;</div><div class="line">        objc_property_attribute_t attr = attrs[j];</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * name = attr.name;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * value = attr.value;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"属性特性名称：%s 值：%s"</span>, name, value);</div><div class="line">    &#125;</div><div class="line">    free(attrs);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\n"</span>);</div><div class="line">&#125;</div><div class="line">free(properties);</div></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以结合上表理解</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性 str 的描述为 T<span class="string">@"NSString"</span>,C,N,V_str</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：T 值：<span class="string">@"NSString"</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：C 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：N 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：V 值：_str</div><div class="line"></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性 array 的描述为 T<span class="string">@"NSArray"</span>,R,N,V_array</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：T 值：<span class="string">@"NSArray"</span></div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：R 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：N 值：</div><div class="line">[<span class="number">24076</span>:<span class="number">1005550</span>] 属性特性名称：V 值：_array</div></pre></td></tr></table></figure></p>
<p>通过上面的简单总结，我对Objective-C类与对象的底层实现有了更深的理解，同时也感受到了<code>runtime</code>的强大。下篇文章我会总结一下方法、消息的结构与操作函数，敬请期待~</p>
<p>参考链接：<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html" target="_blank" rel="external">Objective-C Runtime官方文档</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="external">Objective-C Runtime Programming Guide</a><br><a href="http://southpeak.github.io/categories/objectivec/" target="_blank" rel="external">南大runtime总结</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS性能优化UI篇（二）]]></title>
      <url>/2017/06/29/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96UI%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>书接上回，我们来聊一下UI性能优化的几大重点对象。</p>
<h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><p>我相信每一位iOS开发人员写<code>UITableView</code>肯定都要写吐了，但是大家确定在写的时候都注意到这些原则or细节了吗？</p>
<ul>
<li>尽量避免动态高度的cell，如果已确定控件的高度，直接使用<code>tableView</code>的<code>rowHeight</code>、<code>sectionHeaderHeight</code>和<code>sectionFooterHeight</code>设置高度，避免请求delegate。在<code>heightForRowAtIndexPath:</code>中尽量不使用<code>cellForRowAtIndexPath:</code>，如果你需要用到它，最好只用一次然后缓存结果。<a id="more"></a></li>
<li>使用<code>dequeueReusableCellWithIdentifier:</code>或<code>dequeueReusableCellWithIdentifier:forIndexPath:</code>复用cell，后者需要搭配<code>registerClass/Nib:forCellReuseIdentifier:</code>使用，该方法会在默认没有cell可复用的时候自动创建一个新的cell出来，推荐使用后者。</li>
<li>对于动态高度的cell，做对应标记，缓存行高。推荐使用sunnyxx大神的<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">UITableView-FDTemplateLayoutCell</a>。如果cell对应的模型没有发生变化，则不做相应的计算渲染处理。</li>
<li>使用自定义视图构造的cell，要避免调用<code>layoutIfNeeded</code>每次对其进行布局。尽量固定cell子视图的尺寸，确保每个cell渲染所需时间最小化。<br>尽量使用不透明的子视图，包括cell本身，这点已经在上篇基本法中提过。<br>确保cell的子视图数量最少，避免耗费性能的操作，如图片的缩放、渐变等。<br>如果自定义cell的样式基本确定不会发生大的布局变化，或者在滑动时有明显的性能问题，那么你可能需要异步绘制这个cell，我会在自定义视图部分讲解。</li>
<li>在快速滚动时如果出现了卡顿，那么你除了使用异步绘制cell，还可以考虑使用‘‘占位’’cell，这种方式在国内的App比较少见，如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-26/41893848.jpg" alt="图1"><br>‘‘占位’’cell类似于占位图，它告诉用户这部分即将展示一些信息，当滚动速度降低到一定值时，再展示最终数据。部分代码实现如下：<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</div><div class="line">    <span class="comment">// 通过scrollView的panGestureRecognizer获取滑动速率</span></div><div class="line">    <span class="keyword">self</span>.velocity = [scrollView.panGestureRecognizer velocityInView:<span class="keyword">self</span>.view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="comment">// 根据滑动速率做相应内容展示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.velocity.y &gt; maxVelocity) &#123;</div><div class="line">        <span class="keyword">return</span> placeholderCell;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> cell;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>还有一种sao套路是按需加载cell<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    <span class="keyword">if</span> (labs(cip.row - ip.row) &gt; skipCount) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        <span class="keyword">if</span> (velocity.y &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            <span class="keyword">if</span> (indexPath.row + <span class="number">3</span> &lt; datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="keyword">if</span> (indexPath.row &gt; <span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在`tableView:cellForRowAtIndexPath:`方法中加入判断：，修改样式</span></div><div class="line"><span class="keyword">if</span> (needLoadArr.count &gt; <span class="number">0</span></div><div class="line">    &amp;&amp;</div><div class="line">    [needLoadArr indexOfObject:indexPath] == <span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>详见<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="external">VVeboTableViewDemo</a></p>
<h3 id="UIWebView、WKWebView"><a href="#UIWebView、WKWebView" class="headerlink" title="UIWebView、WKWebView"></a>UIWebView、WKWebView</h3><p>由于H5具有动态化，不用发版等优势，越来越多的H5页面出现的原生App中。苹果提供了两种加载H5的控件，<code>UIWebView</code>,<code>WKWebView</code>，<code>WKWebView</code>是iOS8的新特性，通过简单的测试即可发现UIWebView占用过多内存，且内存峰值更是夸张。WKWebView网页加载速度更快，占用内存更小，下面列举一些其它的优势：</p>
<ul>
<li>支持更多的H5特性</li>
<li>60fps的滚动刷新率及内置手势</li>
<li>与Safari相同的JavaScript引擎</li>
<li>将<code>UIWebView</code>和<code>UIWebViewDelegate</code>重构成了14个类，3个协议，可以让开发者进行更细致的配置</li>
</ul>
<p>简直完爆<code>UIWebView</code>，所以想要优化你的webView，那么从现在开始弃<code>UIWebView</code>，用<code>WKWebView</code>吧！下面简单介绍一下<code>WKWebView</code>。  </p>
<h4 id="加载页面"><a href="#加载页面" class="headerlink" title="加载页面"></a>加载页面</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import<span class="meta-string">&lt;WebKit/WebKit.h&gt;</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)loadRequest &#123;</div><div class="line">    _wkWebView = [[<span class="built_in">WKWebView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds configuration:[<span class="built_in">WKWebViewConfiguration</span> new]]; </div><div class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.wonkeyz.com/"</span>]];</div><div class="line">    [_wkWebView loadRequest:request];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="原生调用JS"><a href="#原生调用JS" class="headerlink" title="原生调用JS"></a>原生调用JS</h4><p>1.使用<code>WKUserScript</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JS代码</span></div><div class="line"><span class="built_in">NSString</span> *js = <span class="string">@"window.alert('测试原生调用JS');"</span>;</div><div class="line"><span class="comment">// 根据JS代码初始化WKUserScript对象</span></div><div class="line"><span class="built_in">WKUserScript</span> *script = [[<span class="built_in">WKUserScript</span> alloc] initWithSource:js injectionTime:<span class="built_in">WKUserScriptInjectionTimeAtDocumentEnd</span> forMainFrameOnly:<span class="literal">YES</span>];</div><div class="line"><span class="comment">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</span></div><div class="line"><span class="built_in">WKWebViewConfiguration</span> *config = [<span class="built_in">WKWebViewConfiguration</span> new];</div><div class="line">[config.userContentController addUserScript:script];</div></pre></td></tr></table></figure></p>
<p>2.直接调用JS代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[_wkWebView evaluateJavaScript:js completionHandler:^(<span class="keyword">id</span> _Nullable, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">        <span class="comment">// 获取js方法返回值，回调操作等</span></div><div class="line">    &#125;];</div></pre></td></tr></table></figure></p>
<h4 id="JS调用原生"><a href="#JS调用原生" class="headerlink" title="JS调用原生"></a>JS调用原生</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向JS注入OC方法</span></div><div class="line">[[_webView configuration].userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@"ocMethod"</span>];</div><div class="line"></div><div class="line"><span class="comment">// JS调用</span></div><div class="line">window.webkit.messageHandlers.ocMethod.postMessage(value);</div><div class="line"></div><div class="line"><span class="comment">// 接收JS调用</span></div><div class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JS 调用了 %@ 方法，传回参数 %@"</span>,message.name,message.body);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这么简单！不过<code>WKWebView</code>还是有一些坑的，有很多相关文章，这里奉上几篇大佬的总结<a href="http://www.jianshu.com/p/403853b63537" target="_blank" rel="external">WKWebView的使用和各种坑的解决方法（OC＋Swift）</a>，<a href="http://www.jianshu.com/p/7bb5f15f1daa" target="_blank" rel="external">WKWebView学习笔记</a>。</p>
<h3 id="自定义视图的绘制"><a href="#自定义视图的绘制" class="headerlink" title="自定义视图的绘制"></a>自定义视图的绘制</h3><p>我们来做一个简单的demo，如图：<img src="http://owgqmweju.bkt.clouddn.com/17-10-27/22309726.jpg" alt="图2"><br>正常代码布局就不写了，这里给出绘制代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"drink.jpg"</span>];</div><div class="line">        <span class="built_in">CGRect</span> imageFrame = <span class="built_in">CGRectMake</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">80</span>, <span class="number">80</span>);</div><div class="line">        [image drawInRect:imageFrame];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *title = <span class="string">@"This is title,This is title,This is title,This is title"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *titleFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : titleFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> titleFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">10</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">30</span>);</div><div class="line">        [title drawInRect:titleFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *content = <span class="string">@"This is content,This is content,This is content,This is content,This is content"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *contentFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">13</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : contentFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kLigthTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> contentFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">40</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">40</span>);</div><div class="line">        [content drawInRect:contentFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSString</span> *time = <span class="string">@"This is time"</span>;</div><div class="line">        <span class="built_in">UIFont</span> *timeFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">12</span>];</div><div class="line">        <span class="built_in">NSDictionary</span> *attrs = @&#123;<span class="built_in">NSFontAttributeName</span> : timeFont,</div><div class="line">                                <span class="built_in">NSForegroundColorAttributeName</span> : kLigthTextColor</div><div class="line">                                &#125;;</div><div class="line">        <span class="built_in">CGRect</span> timeFrame = <span class="built_in">CGRectMake</span>(<span class="number">105</span>, <span class="number">80</span>, <span class="keyword">self</span>.width - <span class="number">125</span>, <span class="number">20</span>);</div><div class="line">        [time drawInRect:timeFrame withAttributes:attrs];</div><div class="line">    &#125;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, kLineBackColor.CGColor);</div><div class="line">        <span class="built_in">CGContextStrokeRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.height - kLineHeight, <span class="keyword">self</span>.width, kLineHeight));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比一下渲染时间，左为复合视图方式，右为直接绘制<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-27/34929283.jpg" alt="图3"><br>通过对比发现绘制得到的cell渲染时间缩短明显，对于更复杂的界面性能优势可想而知。因此，从性能角度来看，直接绘制视图是个不错的选择，但从维护角度来看，代码会比较难维护迭代，所以在某些界面样式稳定下来，你可以考虑重构成绘制视图。或者直接使用上文提到的高性能框架<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYkit</a>、<a href="https://github.com/TextureGroup/Texture" target="_blank" rel="external">Texture</a>。</p>
<h3 id="Auto-Layout"><a href="#Auto-Layout" class="headerlink" title="Auto Layout"></a>Auto Layout</h3><p>再补充一下比较具有争议性的Auto Layout，它给我们日常开发带来了很大的便利，但便利的代价就是耗费更多的性能。<br>Auto Layout使用Cassowary算法作为约束求解工具包，他的复杂度为O（N），其中N是约束的数目，而不是元素的数目。这意味着，在一般情况下，为了确定视图中所有元素的位置和大小，可能有大概4N个方程要求解，而且方程花费的时间与元素的个数和包含的约束个数是不成比例的。当视图数量增加至几百个，直接设设置结构大小要比用自动布局快1000倍左右！(测试demo<a href="https://github.com/floriankugler/AutoLayoutProfiling" target="_blank" rel="external">AutoLayoutProfiling</a>)<br>更详细的分析请见<a href="https://draveness.me/layout-performance" target="_blank" rel="external">从 Auto Layout 的布局算法谈性能</a>。<br>所以当你为某个使用Auto Layout的界面性能消耗苦恼时，那么请改为代码布局吧😂  </p>
<p>UI篇的性能优化就总结到这，菜鸟第一次写这类文章还请各位大佬多包涵，只求别辣到各位大佬的双眼😂</p>
]]></content>
      
        
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> UITableView </tag>
            
            <tag> UIWebView </tag>
            
            <tag> WKWebView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS性能优化UI篇（一）]]></title>
      <url>/2017/06/24/iOS%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96UI%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p> 这是一个老生常谈的话题，程序猿的一生除了在编译、写bug、改bug，就是在不断地重构优化，优化的点也多种多样，其中最直观有效的就是UI部分的优化了，这方面有很多相关资料，也有如<a href="https://github.com/ibireme/YYKit" target="_blank" rel="external">YYkit</a>、<a href="https://github.com/TextureGroup/Texture" target="_blank" rel="external">Texture</a>这种神级框架从根源上解决了卡顿的问题。作为菜鸟的我无法像大佬们一样从根源上分析解决UI性能问题，只能写一篇比较基础的文章，总结一下常用的控件的使用注意点，希望对你的日常开发有帮助~<br> <a id="more"></a></p>
<h3 id="基本法"><a href="#基本法" class="headerlink" title="基本法"></a>基本法</h3><p>先来一波UI操作的基本法则：</p>
<ul>
<li>尽量减少在主线程中的操作，避免阻塞主线程。执行的操作越多就意味着越高的丢帧率，从而导致丢帧卡顿。</li>
<li>尽量保持视图的扁平化，避免视图的多层嵌套。<br>只要给视图添加子视图，或其子视图布局发生变化都会触发父视图的<code>layoutSubviews</code>方法，如果一个视图被塞了很多子视图，性能消耗可想而知。那么这种情况如何避免呢？最好的方法是自定义视图绘制。这样只会触发一个视图的绘制方法，而不是多个子视图的，同时避免了父视图多次调用<code>layoutSubviews</code>和<code>drawRect:</code>方法，具体操作文中会给出demo。  </li>
<li>尽量使用不透明视图。<br>当一个view是透明的，iOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多subviews。这是一个非常耗时的过程。不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的<code>opaque</code>属性设为YES（默认值）。</li>
<li>一些情况下避免使用具有通用目的及功能丰富的控件，系统控件虽然方便，但有时也会带来不必要的消耗，你可以通过封装视图绘制内容来代替。如只显示大段纯文本，那么不必使用功能复杂的<code>UILabel</code>。</li>
<li>尽量延迟加载、重用复杂视图。<br>这点我相信大家在使用<code>UITableView</code>、<code>UICollectionView</code>时都深有体会，如果你对机制足够了解，那么在使用<code>UIScrollView</code>时也可以尝试使用重用机制。</li>
<li>尽量避免出现较大的xib或storyboard。sb固然强大，但整个XML文件在使用之前必须被解析和加载，所以应该最小化sb中的单元数目，创建多个sb或xib，这样不仅有助于减少应用启动时间，还能降低整体内存消耗。</li>
</ul>
<p>聊完基本法，我们来聊一下几个常见视图，看看有哪些性能小技巧。</p>
<h4 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h4><p>这绝对是你用的最多的控件，看似简单，但你真的了解它的性能消耗点吗？先来看看他有多复杂。<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-19/50317192.jpg" alt="图1"><br>图中的每一项设置都会增加<code>UILabel</code>的渲染代价，具体步骤如下：<br>1.使用字体样式及要被渲染的文本时，计算需要的像素数，这是一个消耗较大的过程，应尽量少做。<br>2.检查要被渲染的宽度。<br>3.检查<code>numberOfLines</code>，计算将要展示的行数。<br>4.<code>sizeToFit</code>是否被调用，调用则计算高度，未调用则检查当前尺寸是否能展示完整内容。<br>5.如果size不够展示，则使用<code>lineBreakMode</code>确定隐藏或截断的位置。<br>6.检查其他配置选项，如纯文本or富文本，富文本的样式，对齐方式，自动收缩等。<br>7.最后使用字体、类型及颜色等渲染最终显示的文本。<br>整个过程下来的渲染代价不容小觑，所以平时使用要避免一些不必要的性能浪费。<br>ps：有时会发现label的文字变模糊，那么你需要检查一下label的frame是否都为整数。</p>
<h4 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h4><p>按钮同样无处不在，样式多变、功能强大的它渲染方式主要有以下四种：</p>
<ul>
<li>使用自定义文本默认渲染</li>
<li>全尺寸资源渲染</li>
<li>可变尺寸资源渲染</li>
<li>使用<code>CALayer</code>和贝塞尔曲线自定义绘制</li>
</ul>
<p>下表简单列出了几种渲染方式的利弊。具体见<a href="https://robots.thoughtbot.com/designing-for-ios-taming-uibutton#advantages-of-bezier-approach" target="_blank" rel="external">Designing for iOS: Taming UIButton</a>。</p>
<table>
<thead>
<tr>
<th>渲染方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>自定义文本</td>
<td>简单易用</td>
<td>样式单一</td>
</tr>
<tr>
<td>全尺寸资源</td>
<td>可自定义背景图 <br> 样式多变 <br> 可实现A/B测试</td>
<td>图片导致ipa包变大</td>
</tr>
<tr>
<td>可变尺寸资源</td>
<td>ipa包大小增量较全尺寸小</td>
<td>资源的任何更改可能都会重新计算<code>UIEdgeInsets</code></td>
</tr>
<tr>
<td>自定义绘制</td>
<td>高度自定义样式</td>
<td>随着迭代代码回越发臃肿</td>
</tr>
</tbody>
</table>
<p>通过上面的比较，你需要权衡一下利弊，到底是要性能能还是要ipa包保持合适的大小。</p>
<h4 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h4><p>图像的使用也很简单，但在渲染代价较大的UI元素中，图像首屈一指。在使用UIImage、UIImageView时，注意以下几点有助于性能提升：</p>
<ul>
<li>加载图片的方式有三种<code>imageNamed:</code>、<code>imageWithContentsOfFile:</code>、<code>imageWithData:</code>，正确选择图片加载方式能够对内存优化起到很大的作用。<br><code>imageNamed:</code>优点在于可以缓存已经加载的图片，确保内容只被加载至内存一次，这对于图像的重复利用是非常有优势的。对于常用的小图推荐使用该方法，可以节省出每次都从磁盘加载图片的时间，这样能更好的响应用户的操作。<br><code>imageWithContentsOfFile:</code>和<code>imageWithData:</code>这两种方法的本质是一样的， 都是简单的加载图片，并不会将图片缓存起来，图像会被系统以数据方式加载到界面。一些不常用的大图推荐使用这两种方法，这样就不会缓存这些图片占用内存。</li>
<li>对于网络图像，使用高性能的图像缓存库，如<a href="https://github.com/ibireme/YYWebImage" target="_blank" rel="external">YYWebImage</a>、<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>。</li>
<li>在图片格式的选择上同样很有讲究，选择合适的格式能够为你的应用带来最佳体验，这里奉上YY大神的博文<a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端图片格式调研</a>。</li>
<li>载入的图片与<code>UIImageView</code>尺寸相同。因为调整图片尺寸是一个性能消耗较大的操作，如果图像在<code>UIScrollView</code>中，则消耗更大。如果图片来自网络下载，那么尽量做到下载的图片与视图尺寸匹配，或者对图片进行预处理，调整尺寸。</li>
<li>在非主线程中解压JPG/PNG图片，最好在一个专用队列中执行。</li>
<li>在一些界面的实现上，确定是否真的需要图片。如展示一个评分控件<img src="http://owgqmweju.bkt.clouddn.com/17-10-20/33841778.jpg" alt="enter image description here">，那么最好通过直接绘制，调整透明度或覆盖来实现，而不是使用多张图片。类似情况的取舍既可以优化性能，还能给安装包瘦身。</li>
</ul>
<p>先总结到这里，下篇我会总结一些关于<code>UITableView</code>、<code>WebView</code>和自定义视图的性能优化点，敬请期待！</p>
]]></content>
      
        
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[仿Facebook点赞动画]]></title>
      <url>/2017/06/20/%E4%BB%BFFacebook%E7%82%B9%E8%B5%9E%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p>一个简单的点赞动画，网上有很多实现方式，但觉得不对路，于是自己动起手来写了一个，效果如图：<br><img src="http://owgqmweju.bkt.clouddn.com/17-10-16/8652901.jpg" alt="图1"></p>
<a id="more"></a>
<h3 id="拆解动画"><a href="#拆解动画" class="headerlink" title="拆解动画"></a>拆解动画</h3><p>无论动画多复杂（虽然这个并不复杂😂），我相信都是由若干简单的动画组成的，下面来拆解一下这个动画，逐一实现效果自然就达到了~</p>
<ul>
<li>按钮缩放动画</li>
<li>粒子爆炸动画</li>
</ul>
<h3 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h3><p>缩放动画实现起来很简单，这里用到了帧动画，直接上代码，一目了然~<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - Target Method</span></div><div class="line">- (<span class="keyword">void</span>)clickButtonAction &#123;</div><div class="line">    <span class="keyword">self</span>.selected = !<span class="keyword">self</span>.selected;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.selected) &#123;</div><div class="line">        [<span class="keyword">self</span> popOutside];</div><div class="line">        [_explodeView animate];</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> popInside];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Animate Methods</span></div><div class="line">- (<span class="keyword">void</span>)popInside &#123;</div><div class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">.5</span>f delay:<span class="number">0</span> options:<span class="number">0</span> animations:^&#123;</div><div class="line">        </div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0</span></div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">.7</span>f, <span class="number">.7</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">2.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.</span>f, <span class="number">1.</span>f);</div><div class="line">                                      &#125;];</div><div class="line">    &#125; completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)popOutside &#123;</div><div class="line">    <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">    </div><div class="line">    [<span class="built_in">UIView</span> animateKeyframesWithDuration:<span class="number">.5</span>f delay:<span class="number">0</span> options: <span class="built_in">UIViewKeyframeAnimationOptionCalculationModeCubicPaced</span> animations: ^&#123;</div><div class="line">        </div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">0</span></div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">.8</span>f, <span class="number">.8</span>f);</div><div class="line">                                      &#125;];</div><div class="line">        [<span class="built_in">UIView</span> addKeyframeWithRelativeStartTime:<span class="number">2</span> / <span class="number">3.</span>f</div><div class="line">                                relativeDuration:<span class="number">1</span> / <span class="number">3.</span>f</div><div class="line">                                      animations:^&#123;</div><div class="line">                                          <span class="keyword">self</span>.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.</span>f, <span class="number">1.</span>f);</div><div class="line">                                      &#125;];</div><div class="line">    &#125; completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="粒子动画"><a href="#粒子动画" class="headerlink" title="粒子动画"></a>粒子动画</h3><p>这个爆炸效果是不是看起来很眼熟？没错其实它跟烟花、下雪的动画实现是一样的，都用到了<code>CALayer</code>的一个高性能原生粒子引擎<a href="https://developer.apple.com/documentation/quartzcore/caemitterlayer" target="_blank" rel="external">CAEmitterLayer</a>。<br>简单介绍一下<code>CAEmitterLayer</code>，<code>CAEmitterLayer</code>相当于<code>CAEmitterCell</code>的容器，每一个cell相当于一个粒子，我们只需要定义一个<code>CAEmitterCell</code>粒子效果来作为粒子样式模板，比如粒子的图片、生成率、生命周期等参数，<code>CAEmitterLayer</code>会基于模板实例化该样式的粒子流，根据设置好的发射位置、发射模式、形状使他们动起来。具体代码如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setupEmitterLayer &#123;</div><div class="line">    <span class="keyword">self</span>.clipsToBounds = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">self</span>.userInteractionEnabled = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//创建粒子</span></div><div class="line">    <span class="built_in">CAEmitterCell</span> *emitter = [<span class="built_in">CAEmitterCell</span> emitterCell];</div><div class="line">    emitter.contents        = (<span class="keyword">id</span>)[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"like_dot"</span>].CGImage;</div><div class="line">    emitter.name            = <span class="string">@"emitterCell"</span>;</div><div class="line">    emitter.birthRate       = <span class="number">0</span>;</div><div class="line">    emitter.lifetime        = <span class="number">.7</span>f;</div><div class="line">    emitter.lifetimeRange   = <span class="number">.3</span>f;</div><div class="line">    emitter.alphaRange      = <span class="number">.2</span>f;</div><div class="line">    emitter.alphaSpeed      = <span class="number">-1.</span>f;</div><div class="line">    emitter.velocity        = <span class="number">40.</span>f;</div><div class="line">    emitter.velocityRange   = <span class="number">10.</span>f;</div><div class="line">    emitter.emissionRange   = M_PI_4;</div><div class="line">    emitter.scale           = <span class="number">.05</span>f;</div><div class="line">    emitter.scaleRange      = <span class="number">.02</span>f;</div><div class="line">    </div><div class="line">    <span class="comment">//创建粒子图层</span></div><div class="line">    _emitterLayer = [<span class="built_in">CAEmitterLayer</span> layer];</div><div class="line">    _emitterLayer.name              = <span class="string">@"emitterLayer"</span>;</div><div class="line">    _emitterLayer.frame             = <span class="keyword">self</span>.bounds;</div><div class="line">    _emitterLayer.emitterShape      = kCAEmitterLayerCircle;</div><div class="line">    _emitterLayer.emitterMode       = kCAEmitterLayerOutline;</div><div class="line">    _emitterLayer.emitterPosition   = <span class="keyword">self</span>.center;</div><div class="line">    _emitterLayer.emitterSize       = <span class="built_in">CGSizeMake</span>(<span class="number">25</span>, <span class="number">0</span>);</div><div class="line">    _emitterLayer.renderMode        = kCAEmitterLayerOldestFirst;</div><div class="line">    _emitterLayer.masksToBounds     = <span class="literal">NO</span>;</div><div class="line">    _emitterLayer.emitterCells      = @[emitter];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer: _emitterLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Public Methods</span></div><div class="line">- (<span class="keyword">void</span>)animate &#123;</div><div class="line">    [_emitterLayer removeAnimationForKey:<span class="string">@"likeAnimation"</span>];</div><div class="line">    dispatch_time_t delay = dispatch_time(DISPATCH_TIME_NOW, <span class="number">.2</span>f * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    dispatch_after(delay, dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">self</span>.emitterLayer.beginTime = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        <span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath: <span class="string">@"emitterCells.emitterCell.birthRate"</span>];</div><div class="line">        animation.fromValue = @<span class="number">0</span>;</div><div class="line">        animation.toValue = @<span class="number">600</span>;</div><div class="line">        [_emitterLayer addAnimation:animation forKey:<span class="string">@"likeAnimation"</span>];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>搞定！如果对帧动画和粒子动画有疑问可以看下面两篇文章：<br><a href="http://www.jianshu.com/p/a071bba99a1b" target="_blank" rel="external">Transform和KeyFrame动画</a><br><a href="https://segmentfault.com/a/1190000008580771" target="_blank" rel="external">CAEmitterLayer和CAEmitterCell的基本用法</a></p>
<p>demo地址：<a href="https://github.com/zhangMax/WZLikeButton" target="_blank" rel="external">WZLikeButton</a></p>
]]></content>
      
        
        <tags>
            
            <tag> animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Stay hungry, Stay foolish.]]></title>
      <url>/2017/06/13/Stay-hungry-Stay-foolish/</url>
      <content type="html"><![CDATA[<p>做了一年多iOS开发的菜鸟一只，平时喜欢看各种大佬的博客，获益良多，但随着年龄的增长，记性越来越差…看过的东西如果不记在小本本上，怕不是要忘光…所以弄了个博客，记录平时工作中遇到的坑，以及拜读大佬博客的一些‘‘领悟’’，希望自己能坚持下去，也希望能给大家带来一些帮助。</p>
]]></content>
      
        
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
